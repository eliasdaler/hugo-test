<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Elias Daler's blog</title><link>https://eliasdaler.github.io/hugo-test/posts/</link><description>Recent content in Posts on Elias Daler's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 12 Jan 2022 14:22:34 +0300</lastBuildDate><atom:link href="https://eliasdaler.github.io/hugo-test/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>My First Post</title><link>https://eliasdaler.github.io/hugo-test/posts/my-first-post/</link><pubDate>Wed, 12 Jan 2022 14:22:34 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/my-first-post/</guid><description>&lt;p>Hello world.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="font-weight:bold">func&lt;/span> &lt;span style="color:#900;font-weight:bold">x&lt;/span>() {
&lt;span style="font-weight:bold">if&lt;/span> x &lt;span style="font-weight:bold">==&lt;/span> &lt;span style="color:#099">5&lt;/span> {
&lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">nil&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Re:creation dev log. December 2016 - March 2017.</title><link>https://eliasdaler.github.io/hugo-test/posts/re-creation-devlog-december-march/</link><pubDate>Wed, 19 Apr 2017 23:00:00 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/re-creation-devlog-december-march/</guid><description>&lt;p>No posts in four months! And I haven&amp;rsquo;t worked on the game for the last one and a half. Is the project dead? No! Let&amp;rsquo;s pretend that nothing happened and I&amp;rsquo;ll show what I did since December and will tell about my future plans in the end.&lt;/p>
&lt;figure>&lt;img src="child-parent.gif"/>&lt;figcaption>
&lt;h4>Child-parent example&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;div>
&lt;h2>Table Of Contents&lt;/h2>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#lots-of-work-moving-everything-to-lua">Lots of work! Moving everything to Lua&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gui">GUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="#some-small-c-related-refactorings">Some small C++ related refactorings&lt;/a>&lt;/li>
&lt;li>&lt;a href="#levels-and-tile-maps">Levels and tile maps&lt;/a>&lt;/li>
&lt;li>&lt;a href="#child-parent-hierarchy-and-relative-transforms">Child-parent hierarchy and relative transforms&lt;/a>&lt;/li>
&lt;li>&lt;a href="#other-small-things">Other small things&lt;/a>&lt;/li>
&lt;li>&lt;a href="#conclusion-and-plans">Conclusion and plans&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/div>
&lt;h2 id="lots-of-work-moving-everything-to-lua">Lots of work! Moving everything to Lua&lt;/h2>
&lt;p>I moved a lot of code to Lua! For quite some time I thought that this didn&amp;rsquo;t make much sense or was very difficult, but turns out it&amp;rsquo;s easier as the more and more code gets moved to Lua. Here&amp;rsquo;s a comparison of lines of code between two dates.&lt;/p>
&lt;p>&lt;strong>27.11.2016&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Language&lt;/th>
&lt;th>files&lt;/th>
&lt;th>blank&lt;/th>
&lt;th>comment&lt;/th>
&lt;th>code&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>C++&lt;/td>
&lt;td>103&lt;/td>
&lt;td>2420&lt;/td>
&lt;td>533&lt;/td>
&lt;td>13073&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Lua&lt;/td>
&lt;td>116&lt;/td>
&lt;td>510&lt;/td>
&lt;td>154&lt;/td>
&lt;td>5071&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C/C++ header&lt;/td>
&lt;td>123&lt;/td>
&lt;td>1386&lt;/td>
&lt;td>158&lt;/td>
&lt;td>4315&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>22.02.2017&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Language&lt;/th>
&lt;th>files&lt;/th>
&lt;th>blank&lt;/th>
&lt;th>comment&lt;/th>
&lt;th>code&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>C++&lt;/td>
&lt;td>109&lt;/td>
&lt;td>1938&lt;/td>
&lt;td>330&lt;/td>
&lt;td>10590&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Lua&lt;/td>
&lt;td>127&lt;/td>
&lt;td>706&lt;/td>
&lt;td>135&lt;/td>
&lt;td>5167&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C/C++ header&lt;/td>
&lt;td>133&lt;/td>
&lt;td>1296&lt;/td>
&lt;td>90&lt;/td>
&lt;td>4014&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Note, that even though I&amp;rsquo;ve added a lot of new code, the resulting code is still smaller. And Lua code became larger just by 100 lines, even though I moved a lot of C++ code here! This may also look as a little work was done, but &lt;code>git diff&lt;/code> between commits made in December and March results in this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#099">460&lt;/span> files changed, &lt;span style="color:#099">14486&lt;/span> insertions&lt;span style="font-weight:bold">(&lt;/span>+&lt;span style="font-weight:bold">)&lt;/span>, &lt;span style="color:#099">16035&lt;/span> deletions&lt;span style="font-weight:bold">(&lt;/span>-&lt;span style="font-weight:bold">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s a lot of changes!&lt;/p>
&lt;p>All game-specific components are now in Lua. For example, inventory, health components and others can be implemented in Lua efficiently because I don&amp;rsquo;t have to iterate them in tight loops in every frame. They&amp;rsquo;re mostly used for some basic logic and data storage. Only the following components are implemented in C++ now: Transform, Hierarchy, Graphics, Movement, Sound. As you can see, these components are pretty low-level and are mostly not tied to my game at all, which is great.
Here&amp;rsquo;s an example of a game specific component defined in Lua:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="color:#998;font-style:italic">-- ItemComponent.lua&lt;/span>
&lt;span style="font-weight:bold">local&lt;/span> Component &lt;span style="font-weight:bold">=&lt;/span> require(&lt;span style="color:#b84">&amp;#34;Component&amp;#34;&lt;/span>)
&lt;span style="font-weight:bold">local&lt;/span> ItemComponent &lt;span style="font-weight:bold">=&lt;/span> Component:subclass(&lt;span style="color:#b84">&amp;#34;ItemComponent&amp;#34;&lt;/span>)
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#458;font-weight:bold">ItemComponent&lt;/span>:&lt;span style="color:#900;font-weight:bold">initialize&lt;/span>()
Component:initialize()
self.value &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#099">0&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#458;font-weight:bold">ItemComponent&lt;/span>:&lt;span style="color:#900;font-weight:bold">loadData&lt;/span>(data)
&lt;span style="font-weight:bold">if&lt;/span> data.value &lt;span style="font-weight:bold">then&lt;/span>
self.value &lt;span style="font-weight:bold">=&lt;/span> data.value
&lt;span style="font-weight:bold">end&lt;/span>
self.name &lt;span style="font-weight:bold">=&lt;/span> data.name
self.description &lt;span style="font-weight:bold">=&lt;/span> self.description
self.iconName &lt;span style="font-weight:bold">=&lt;/span> data.iconName
self.onEquipFunc &lt;span style="font-weight:bold">=&lt;/span> data.onEquip
self.onUnequipFunc &lt;span style="font-weight:bold">=&lt;/span> data.onUnequip
self.useFunc &lt;span style="font-weight:bold">=&lt;/span> data.use
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#458;font-weight:bold">ItemComponent&lt;/span>:&lt;span style="color:#900;font-weight:bold">use&lt;/span>(itemOwner)
&lt;span style="font-weight:bold">if&lt;/span> self.useFunc &lt;span style="font-weight:bold">then&lt;/span>
self:useFunc(itemOwner)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#458;font-weight:bold">ItemComponent&lt;/span>:&lt;span style="color:#900;font-weight:bold">onEquip&lt;/span>(itemOwner)
&lt;span style="font-weight:bold">if&lt;/span> self.onEquipFunc &lt;span style="font-weight:bold">then&lt;/span>
self:onEquipFunc(itemOwner)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#458;font-weight:bold">ItemComponent&lt;/span>:&lt;span style="color:#900;font-weight:bold">onUnequip&lt;/span>(itemOwner)
&lt;span style="font-weight:bold">if&lt;/span> self.onUnequipFunc &lt;span style="font-weight:bold">then&lt;/span>
self:onUnequipFunc(itemOwner)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#458;font-weight:bold">ItemComponent&lt;/span>:&lt;span style="color:#900;font-weight:bold">getIconName&lt;/span>()
&lt;span style="font-weight:bold">return&lt;/span> self.iconName
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">return&lt;/span> ItemComponent
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I also moved all of GUI logic to Lua too. The most complex GUI is dialogue GUI. It does a lot of stuff: it displays text character by character, speaking entity&amp;rsquo;s portrait; highlights some words, handles player&amp;rsquo;s choice in dialogues. I didn&amp;rsquo;t think that moving it to Lua would be real as the logic was pretty complex&amp;hellip; but I managed to do it! Here&amp;rsquo;s a reminder of how many things happen in dialogues:&lt;/p>
&lt;figure>&lt;img src="dialogue-cat.gif"/>&lt;figcaption>
&lt;h4>Dialogue example&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Now &lt;code>GuiState&lt;/code> in C++ just iterates over all GUIs in GUI stack and just calls update and draw functions, not caring about game-specific things. Oh yeah, I now have GUI stack, so I can implement complex GUI&amp;rsquo;s which stack on top of each other (e.g. pause screen GUI on top of game GUI)&lt;/p>
&lt;p>By moving some components and all GUI stuff to Lua I finished a pretty important thing: all the game logic is in Lua now! Absolutely everything! This makes me incredibly happy and lets me easily implement new things without caring how Lua and C++ will interact. And another great thing is that the code is now easier to read and it 2-3 times smaller!&lt;/p>
&lt;p>I also implemented game mode stack in Lua, which was previously handled in C++. This means that I can easily create new game modes without touching any C++ code.&lt;/p>
&lt;p>This makes my engine a lot more generic and separates it from the game, which is great. This means that I can easily reuse my engine in other projects later: I&amp;rsquo;ll just have to change scripts and resources and most of the C++ code will remain the same. I will probably explain my current engine structure a bit later, once I&amp;rsquo;m 100% confident that it works great.&lt;/p>
&lt;h2 id="gui">GUI&lt;/h2>
&lt;p>Let&amp;rsquo;s talk about GUI a bit more. First of all, now there&amp;rsquo;s a good parent-child relation between elements. I store child offset relative to parent, so I can easily group and move things together. For example, a portrait of talker is a child of a dialogue window and its relative position to the border of the window is (6,8). So if I render the dialogue window at (100, 200), I&amp;rsquo;ll render the dialogue portait at (106, 208) by combining local child&amp;rsquo;s transform and parent&amp;rsquo;s transform.&lt;/p>
&lt;p>I also implemented nine-patch windows. Previously I just stored a big sprites of windows, but now I can just store them like this:&lt;/p>
&lt;figure>&lt;img src="gui-nine-patch.png"/>&lt;figcaption>
&lt;h4>Nine-patch texture&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>and with some texture repeating, flipping and mirroring, I can get the dialogue window!
&lt;figure>&lt;img src="dialogue-window.png"/>&lt;figcaption>
&lt;h4>Resulting dialogue box&lt;/h4>
&lt;/figcaption>
&lt;/figure>
This not only saves texture space, but also allows me to easily create windows of different sizes.&lt;/p>
&lt;h2 id="some-small-c-related-refactorings">Some small C++ related refactorings&lt;/h2>
&lt;ul>
&lt;li>Added lots of &lt;code>const&lt;/code> where possible. The game was const correct most of the time, but there are quite a few places where I made non-const local variables which don&amp;rsquo;t change or failed to make some member function const, which they later became with some effort. Turns out that most of the time the things stay constant and very few things change, that&amp;rsquo;s why having most of the stuff const is great: you can easily see things that &lt;strong>do&lt;/strong> change.&lt;/li>
&lt;li>Stopped passing pointers in most functions and now pass everything by reference unless the pointer is really needed. A lot of this was in very old code, when I didn&amp;rsquo;t realize how perfect references are.&lt;/li>
&lt;li>Started using &lt;code>std::reference_wrapper&lt;/code> instead of raw non-owning pointers for storing references to stuff in &lt;code>std::vector&lt;/code>. This is a very useful indicator of &amp;ldquo;hey, this is just a reference!&amp;rdquo;&lt;/li>
&lt;li>Stopped handling each axis separately in some places, making changes like this:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">someX &lt;span style="font-weight:bold">=&lt;/span> otherX &lt;span style="font-weight:bold">+&lt;/span> &lt;span style="color:#099">5&lt;/span>;
someY &lt;span style="font-weight:bold">=&lt;/span> otherY &lt;span style="font-weight:bold">+&lt;/span> &lt;span style="color:#099">10&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and now I do this instead:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">someVector &lt;span style="font-weight:bold">+=&lt;/span> otherVector &lt;span style="font-weight:bold">+&lt;/span> sf&lt;span style="font-weight:bold">::&lt;/span>Vector2f(&lt;span style="color:#099">5&lt;/span>, &lt;span style="color:#099">10&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I used a lot of vectors before, but there were still places where I did computations for each vector&amp;rsquo;s coordinate or stored coordinates in two variables. It was pretty dumb, because most of the time you do the same thing for both X and Y, and duplicating the same code is not smart.&lt;/p>
&lt;ul>
&lt;li>Introduced lots of type aliases, for example &lt;code>TileIndex&lt;/code> instead of &lt;code>sf::Vector2i&lt;/code>, &lt;code>ComponentList&lt;/code> instead of &lt;code>std::vector&amp;lt;std::reference_wrapper&amp;lt;Component&amp;gt;&amp;gt;&lt;/code> and so on (wish there were strong typedefs in C++!). This made code much more readable, because it leaves you with less information and most of the time I just don&amp;rsquo;t care about the underlying type, I care about it&amp;rsquo;s meaning.&lt;/li>
&lt;/ul>
&lt;h2 id="levels-and-tile-maps">Levels and tile maps&lt;/h2>
&lt;p>A huge effort was put into remaking tile map system. Previously each tile map was a grid of chunks (each 8x8 tiles in size). This allowed me to save some space by not having to store a lot of empty tiles. But the data structure was pretty complicated. I used &lt;code>std::vector&amp;lt;std::vector&amp;lt;TilemapChunk&amp;gt;&amp;gt;&lt;/code> and so if some chunks were stored in negative coordinates, I had to store index of top-left chunk and make sure to keep it in mind when accessing other chunks, because I couldn&amp;rsquo;t store negative indices in &lt;code>std::vector&amp;lt;std::vector&amp;lt;TilemapChunk&amp;gt;&amp;gt;&lt;/code>. So, if &lt;code>minChunkIndex&lt;/code> was (-10, -20), I found real index of (-3, -4) chunk in vector of vectors by removing &lt;code>minChunkIndex&lt;/code>: (-3, -4) - (-10, -20) = (7, 16)&lt;/p>
&lt;p>It wasn&amp;rsquo;t very good system for various reasons, so I implemented a simpler structure: &lt;code>std::unordered_map&amp;lt;ChunkIndex, LevelChunk&amp;gt;&lt;/code> (&lt;code>ChunkIndex&lt;/code> is &lt;code>sf::Vector2i&lt;/code>). Now I don&amp;rsquo;t have to store &lt;code>minChunkIndex&lt;/code> and formulas are simplified. I also don&amp;rsquo;t waste space on empty chunks, which is another advantage of new system. It&amp;rsquo;s similar to implementing sparse matrices: instead of having large 2D array, I only store elements which are not zero (not empty in case of tile chunks).&lt;/p>
&lt;p>I also improved a lot of level editor code by completely removing all duplication, encapsulation breaks, etc. I previously thought like this:&amp;ldquo;It&amp;rsquo;s just a development tool, it doesn&amp;rsquo;t have to have very good code!&amp;rdquo;, but turns out that code here matters very much too! First of all, duplication is always bad. Secondly, encapsulation breaks make changes to other classes much harder.&lt;/p>
&lt;p>Thankfully, there weren&amp;rsquo;t much such breaks and I actually made a post previously about how having &lt;code>TileMap::setTile&lt;/code> function saved me a lot of time, as I could easily change data structures of level without having to modify level editor code. But there were still some places in which I had to access some private parts of &lt;code>TileMap&lt;/code>. So I made a lot of getters and setters. And it made &lt;code>TileMap&lt;/code> class not properly encapsulated and much longer than it needed to be. So I found a great alternative.&lt;/p>
&lt;p>&lt;a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client">Attorney-Client pattern&lt;/a> is a great way of solving this problem. Basically, I let some encapsulation breaks by creating LevelModifier structure and making it a friend of TileMap and other level related classes. Now if I need to create an encapsulation breaking function, I create something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#458;font-weight:bold">void&lt;/span> LevelModifier&lt;span style="font-weight:bold">::&lt;/span>setTile(Tilemap&lt;span style="font-weight:bold">&amp;amp;&lt;/span> tilemap, &lt;span style="color:#998;font-style:italic">/* other args */&lt;/span>)
{
... &lt;span style="color:#998;font-style:italic">// can access private data members and member functions of TileMap
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This function is static, so I can later call it in LevelEditor like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">if&lt;/span> (&lt;span style="color:#998;font-style:italic">/* left mouse button clicked */&lt;/span>) {
LevelModifier&lt;span style="font-weight:bold">::&lt;/span>setTile(tileMap, selectedTile);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Awesome. In fact, the number of such encapsulation functions is just 10. Pretty low and easily controllable. If I find myself in a situation where I had to change TileMap class considerably, I&amp;rsquo;ll be confident that I&amp;rsquo;ll have to deal with breaking changes in just a few functions.&lt;/p>
&lt;p>After this experience, I wondered how many functions of other classes I can make private. Previously I made them public by default for some reason, even if they were only called in member functions of this class. I managed to make quite a lot functions private without making significant changes to any code and improved encapsulation by doing so. There&amp;rsquo;s a small advantage to it: I can be sure that changing private function of the class won&amp;rsquo;t need many changes in other places.&lt;/p>
&lt;p>Back to levels. Previously all entity positions were stored in a level file and during level loading I just created each entity and placed them in the right spots of the map. This made some things pretty hard to load/save. I had to store position where entity spawned, I had to know if some entity will be saved to level file or not, etc.&lt;/p>
&lt;p>But then I realized one simple thing: what I considered &amp;ldquo;entity info&amp;rdquo; in level files was actually &amp;ldquo;spawn points info&amp;rdquo;. So if I just stored info about spawn points in tile map, I could then easily spawn entities with them later and also change them in level editor, instead of working with concrete entity instances. So, when I move entity in level editor, I don&amp;rsquo;t just move instance of this entity, but also its corresponding spawn point.&lt;/p>
&lt;p>It&amp;rsquo;s just separation of concerns. Entity doesn&amp;rsquo;t have to know about it&amp;rsquo;s spawn point most of the time. And when I save level, I don&amp;rsquo;t care about particular entities, I just care about spawn points. I can iterate through them and just save their properties. Restoring initial level state is also easier: I can just remove all entities and spawn new ones using spawn points.&lt;/p>
&lt;p>Trying to restore each entity&amp;rsquo;s initial state is more error prone. I guess this method of doing things explains bugs with saves in some games. In Fallout: New Vegas some NPCs may become hostile and attack you because of your actions, and after you reload your save, they may still attack you, even though in the loaded save state they were neutral to you! Probably this is explained by a bug when restoring entity&amp;rsquo;s state, if you reload the game, the game works as usual.&lt;/p>
&lt;p>I also started storing tile maps in JSON. Previously I stored them in a custom plain text format, but as the format got progressively harder to maintain (lots of parsing/saving code), I remade the whole thing in JSON. The code is much simpler to read and expand, so it&amp;rsquo;s great!&lt;/p>
&lt;p>Another thing I made is ability to hold mouse button down and paint tiles. Yes, this seems like a very easy thing to implement, but it wasn&amp;rsquo;t! I had to make sure that I could properly undo this action, create new level chunks on the fly, etc. And now I can easily create maps in any direction with this feature:&lt;/p>
&lt;figure>&lt;img src="infinite-maps.gif"/>
&lt;/figure>
&lt;h2 id="child-parent-hierarchy-and-relative-transforms">Child-parent hierarchy and relative transforms&lt;/h2>
&lt;p>Okay, if I made a more complex game, I would have made this a lot earlier, but here we go. Look at the gif:&lt;/p>
&lt;figure>&lt;img src="child-parent.gif"/>&lt;figcaption>
&lt;h4>Child-parent example&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Hat entity is a child of Renatus entity. Renatus is a child of moving platform entity. This simple hierarchy is easy to handle: the only thing that moves is a platform. It stores coordinate of Renatus relative to it and uses it for relative movement. As Renatus gets moved, the hat moves by the same offset as well. The system is very easy, I just traverse through hierarchy and apply the same movement delta to each entity.&lt;/p>
&lt;p>One small thing had given me lots of headache: sometimes the relative movement was a bit shaky. It was because of float rounding, the picture explains the problem:
&lt;img src="https://eliasdaler.github.io/hugo-test/assets/re_creation_dev_log_dec_march/floor_problem.png" alt="Floor problem">
&lt;figure>&lt;img src="floor-problem.png"/>
&lt;/figure>
In the example both entities move by 0.2 pixels, but due to rounding on the screen, you can see a gap between the two appearing. This was unacceptable!&lt;/p>
&lt;p>Check out the &lt;a href="https://en.sfml-dev.org/forums/index.php?topic=21626">thread I made about this&lt;/a>, if you&amp;rsquo;re interested in my solution. There were some interesting points made in the thread as well.&lt;/p>
&lt;h2 id="other-small-things">Other small things&lt;/h2>
&lt;p>And here are some other small things which I don&amp;rsquo;t want to write about, but if you&amp;rsquo;re interested in some, feel free to ask about them!&lt;/p>
&lt;ul>
&lt;li>Previously all side animations had copies in a sprite sheet (e.g. left and right walking animations). Now I just flip them on GPU by setting texture rect&amp;rsquo;s width to be negative, when I want to flip animation. I&amp;rsquo;ll be doing the same with mirrored/rotated tiles a bit later.&lt;/li>
&lt;li>Stupid collision optimization: I stopped checking collisions between static entities. There&amp;rsquo;s no need to check if static, unmovable tree collides with house or not. Both entities can&amp;rsquo;t move The number of collision checks reduced greatly in the result and collision is very fast now.&lt;/li>
&lt;li>Started using entity handles (see &lt;a href="https://eliasdaler.github.io/game-object-references/">my article&lt;/a> about them)&lt;/li>
&lt;li>Camera is an entity now. Of course, it has properties of an entity: transform, movement component, AI component (used for following the path). So I don&amp;rsquo;t have to rewrite the same code twice and can script all camera logic in Lua.&lt;/li>
&lt;li>Started using seconds instead of milliseconds everywhere. &lt;code>sf::Time::asSeconds&lt;/code> returns a &lt;code>float&lt;/code>, while &lt;code>sf::Time::asMilliseconds&lt;/code> returns a rounded &lt;code>int&lt;/code> (usually 16, corresponding to 60 FPS), the results are terrible for pixel perfect games, especially during camera scrolling. It results in camera having non-smooth movement, which has been a problem I was trying to fix for ages and finally did with such a simple change. Here&amp;rsquo;s &lt;a href="https://plus.google.com/+flibitijibibo/posts/PysMth9Y5kN">a post about the similar problem which FEZ apparently also had&lt;/a> which inspired me to do this.&lt;/li>
&lt;li>Made some multi-threading during loading. Basically, I can do most of the loading in another thread: sounds, scripts, level data, etc. But not textures, because OpenGL is not multi-threaded. The solution is simple: I load textures in RAM first and then move them to GPU in a main thread. It blocks the main thread, but it&amp;rsquo;s pretty fast and not really noticeable.&lt;/li>
&lt;li>Worked on diagonal collision. I previously worked on it, but it was very buggy, as the player could get stuck between tiles (I noticed that some SNES and GBA games have this problem, e.g. Earthbound, Mother 3). But I fixed it! I hope that I&amp;rsquo;ll never have to deal with tile collision in the near future. It&amp;rsquo;s so hard!&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="tile-collision.gif"/>
&lt;/figure>
&lt;p>There are probably a lot of things I missed, but I hope that it&amp;rsquo;s enough to show you how much stuff I&amp;rsquo;ve done.&lt;/p>
&lt;h2 id="conclusion-and-plans">Conclusion and plans&lt;/h2>
&lt;p>This semester is very intense. Lots of homework, project assignments and so on. This was the reason I stopped working on a game for a 1.5 months and probably won&amp;rsquo;t be working on it for another two and a half.&lt;/p>
&lt;p>In the meantime, I will be doing small things about the game which don&amp;rsquo;t require coding: improve plot, think about game mechanics and puzzles, limit my scope, etc. I also plan to read stuff about game development and think how I can further improve my code and engine structure. It&amp;rsquo;s not the main priority now, however. I&amp;rsquo;m mostly happy with most of my code and don&amp;rsquo;t think that a huge changes will come.&lt;/p>
&lt;p>What I want to have in the future is a stable foundation. You know, just some level with a lot of things going on: AI, NPCs, complex tile map, basic combat, particles and so on. A vertical slice of the game, working just fine. The confidence in the code base: that it works well and doesn&amp;rsquo;t require me write a lot of boilerplate code and that I&amp;rsquo;m not limited by it. Good resource system, neat organization in files, smooth content creation and so on.&lt;/p>
&lt;p>These are some things which take a lot of time, but once they&amp;rsquo;re achieved, they can provide a lot of confidence and comfort in the future and save me from having to change a lot of things at once.&lt;/p>
&lt;p>Don&amp;rsquo;t worry about the project: I&amp;rsquo;ve taken a few breaks from it before and coming back was as exciting as ever. As the time goes on, I don&amp;rsquo;t lose any motivation or confidence in it, in fact I love it more and more. And some of you may be disappointed in my slow progress, and I&amp;rsquo;m sorry for it, but not rushing is what makes it such a nice experience for me. And hey, even if you don&amp;rsquo;t get the playable game in the end, you can still learn something from my dev logs and tutorials. If I didn&amp;rsquo;t spend lots of time reiterating, researching, refactoring, I would have never figured out a lot of things which helped a lot of people.&lt;/p>
&lt;p>One more thing: art, dialogue, plot, atmosphere and whole concept just got a lot better as the time went by. If I finished the game with the art, plot and gameplay it had two years ago, it would not be very good. But as my skills improve, I apply them to the game and make it considerably better than before.&lt;/p>
&lt;p>Thanks for reading!&lt;/p></description></item><item><title>Making and storing references to game objects (entities) in C++ and Lua</title><link>https://eliasdaler.github.io/hugo-test/posts/game-object-references/</link><pubDate>Sun, 22 Jan 2017 14:00:00 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/game-object-references/</guid><description>&lt;div>
&lt;h2>Table Of Contents&lt;/h2>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#introduction">Introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shared_ptr-and-weak_ptr">shared_ptr and weak_ptr&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-unique-ids">Using unique ids&lt;/a>&lt;/li>
&lt;li>&lt;a href="#storing-references-to-entities-in-lua">Storing references to entities in Lua&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/div>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;figure>&lt;img src="ids.png"/>
&lt;/figure>
&lt;p>The problem of handling references to game objects (I&amp;rsquo;ll call them &lt;em>entities&lt;/em>) comes up very often. Sometimes it&amp;rsquo;s child-parent relationship between the entities, sometimes it&amp;rsquo;s useful to store a reference to an object in event data, some task scheduling class and so on.&lt;/p>
&lt;p>Sometimes a simple pointer, reference or &lt;code>std::reference_wrapper&lt;/code> is enough. But the problem with raw pointers and references is that once you use them, you have to make sure that the entity which is being referenced stays alive and is not moved in memory without notifying objects which hold references. And with good design you&amp;rsquo;ll probably be able to achieve that.&lt;/p>
&lt;p>But stale pointers/references give some of the worst bugs, which are difficult to track, crash your game and may not be easily identifiable. Some entities may start to occupy different addresses in memory (for example, after you reload a level and decide to create all entities from scratch). While it&amp;rsquo;s possible to manually update all pointers to previously referenced entities, it&amp;rsquo;s certainly will be better to do so automatically and without a chance of forgetting some pointers which will be stale.&lt;/p>
&lt;p>Let&amp;rsquo;s see all these problems can be solved. The latest solution (about storing references to Lua) was discovered by me not long ago and it is the point of me writing the article, but I want to show some other ways of solving the problem. Let&amp;rsquo;s start!&lt;/p>
&lt;h2 id="shared_ptr-and-weak_ptr">shared_ptr and weak_ptr&lt;/h2>
&lt;p>Some of the problems with raw references can be solved with &lt;code>std::shared_ptr&lt;/code> and &lt;code>std::weak_ptr&lt;/code>. First, you create your entities as with &lt;code>std::make_shared&lt;/code>. After that you&amp;rsquo;ll create all references to it with &lt;code>std::weak_ptr&lt;/code>s which won&amp;rsquo;t affect your entity&amp;rsquo;s lifetime. After that you can use &lt;code>std::weak_ptr&amp;lt;T&amp;gt;::expired&lt;/code> function to check if the reference is still valid.&lt;/p>
&lt;p>The solution is not perfect. First of all, it requires you to create all your entities as &lt;code>shared_ptr&lt;/code>s which may have some significant overhead compared to &lt;code>unique_ptr&lt;/code>s. And after all, it&amp;rsquo;s better for the lifetime of entities not to be shared and that semantic is better expressed with &lt;code>unique_ptr&lt;/code>. Shared pointers also don&amp;rsquo;t solve the problem of moving entities in memory: you can&amp;rsquo;t swap what&amp;rsquo;s inside the &lt;code>shared_ptr&lt;/code> and have all &lt;code>weak_ptr&lt;/code>s automatically update their pointers.&lt;/p>
&lt;h2 id="using-unique-ids">Using unique ids&lt;/h2>
&lt;p>One solution to the problem is just creating unique ids for entities and storing those ids instead of raw pointers or references. There a lots of ways to generate and represent entity ids. Ids can just be integers with &lt;code>EntityManager&lt;/code> having a counter which will be incremented as new entities are created: the first entity will get id=0, the second one id=1 and so on. Another way to generate ids is to use some hashing algorithm or &lt;a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID&lt;/a>s. No matter what, your ids should stay unique, unless you add some additional info (like entity creation time or some tags) to your id.&lt;/p>
&lt;p>Here&amp;rsquo;s how your &lt;code>EntityManager&lt;/code> class may look:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="color:#458;font-weight:bold">EntityManager&lt;/span> {
&lt;span style="font-weight:bold">public&lt;/span>&lt;span style="font-weight:bold">:&lt;/span>
Entity&lt;span style="font-weight:bold">*&lt;/span> getEntity(EntityId id) &lt;span style="font-weight:bold">const&lt;/span>;
&lt;span style="color:#458;font-weight:bold">bool&lt;/span> &lt;span style="color:#900;font-weight:bold">entityExists&lt;/span>(EntityId id) &lt;span style="font-weight:bold">const&lt;/span>;
&lt;span style="color:#998;font-style:italic">// ...
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="font-weight:bold">private&lt;/span>&lt;span style="font-weight:bold">:&lt;/span>
std&lt;span style="font-weight:bold">::&lt;/span>unordered_map&lt;span style="font-weight:bold">&amp;lt;&lt;/span>EntityId, std&lt;span style="font-weight:bold">::&lt;/span>unique_ptr&lt;span style="font-weight:bold">&amp;lt;&lt;/span>Entity&lt;span style="font-weight:bold">&amp;gt;&amp;gt;&lt;/span> entities;
&lt;span style="color:#998;font-style:italic">// ...
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using ids also helps with recreation problem: you can easily reload/recreate the entity and just assign the same id to it as before. It will have a different adress in memory, but the next time someone calls &lt;code>getEntity&lt;/code> the updated entity is returned. You can also easily send these ids over the network or save them in your save files.&lt;/p>
&lt;p>Your code when using entity id becomes something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">auto&lt;/span> entityPtr &lt;span style="font-weight:bold">=&lt;/span> g_EntityManager.getEntity(entityId);
entityPtr&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>doSomething();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course this creates some overhead because you now have a layer of indirection: you have to search &lt;code>unordered_map&lt;/code> inside the &lt;code>EntityManager&lt;/code> to get the raw reference to the entity, but if you don&amp;rsquo;t do it too often (and you most likely won&amp;rsquo;t), you&amp;rsquo;ll be fine!&lt;/p>
&lt;p>There&amp;rsquo;s another improvement which can be done: you can wrap your id inside the struct and then overload &lt;code>operator-&amp;gt;&lt;/code> for handle to act like a raw pointer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">struct&lt;/span> &lt;span style="color:#458;font-weight:bold">EntityHandle&lt;/span> {
EntityId id;
EntityManager&lt;span style="font-weight:bold">*&lt;/span> entityManager;
EntityHandle(EntityId id, EntityManager&lt;span style="font-weight:bold">*&lt;/span> entityManager) &lt;span style="font-weight:bold">:&lt;/span>
id(id), entityManager(entityManager)
{}
Entity&lt;span style="font-weight:bold">*&lt;/span> &lt;span style="font-weight:bold">operator&lt;/span>&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>() &lt;span style="font-weight:bold">const&lt;/span> {
&lt;span style="font-weight:bold">return&lt;/span> &lt;span style="color:#900;font-weight:bold">get&lt;/span>();
}
Entity&lt;span style="font-weight:bold">*&lt;/span> &lt;span style="color:#900;font-weight:bold">get&lt;/span>() &lt;span style="font-weight:bold">const&lt;/span> {
assert(entityManager&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>entityExists(id));
&lt;span style="font-weight:bold">return&lt;/span> entityManager&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>getEntity(id);
}
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now you can do things like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">EntityHandle &lt;span style="color:#900;font-weight:bold">handle&lt;/span>(someEntityId, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>g_EntityManager);
handle&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>doSomething();
&lt;span style="color:#998;font-style:italic">// or...
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>
&lt;span style="font-weight:bold">auto&lt;/span> entityPtr &lt;span style="font-weight:bold">=&lt;/span> handle.get();
entityPtr&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>doSomething();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that we also get some error checking with assert which checks validity of the reference.
Great! Now let&amp;rsquo;s see how we can reference entities in Lua scripts.&lt;/p>
&lt;h2 id="storing-references-to-entities-in-lua">Storing references to entities in Lua&lt;/h2>
&lt;blockquote class="hint-info">
Full implementation can be found here: &lt;a href="https://gist.github.com/eliasdaler/f5c2ee50fc7e42bf3ee18ad7d46d18f8">C++ part&lt;/a>, &lt;a href="https://gist.github.com/eliasdaler/f3516d3deabc32b465a7c244ff082cf0">Lua part&lt;/a>.
&lt;/blockquote>
&lt;p>First of all, it&amp;rsquo;s obvious that you can use the same approach in Lua. Your handle can just be a number or a table with &lt;code>__index&lt;/code> meta-method so that you can use your handle as if it was the raw reference. But there&amp;rsquo;s a neater method I recently came up with. Let&amp;rsquo;s see how it works.&lt;/p>
&lt;p>First of all, our handles will be tables with raw C++ references stored in them as userdata. They&amp;rsquo;ll also have a bool named &lt;code>isValid&lt;/code> which will help us test if the handle is still valid. We&amp;rsquo;ll also have a global table of references in Lua, so that you can easily get handle from any place without calling C++. What&amp;rsquo;s neat is that you&amp;rsquo;ll get &lt;strong>references&lt;/strong> to your handles, not a copy. It&amp;rsquo;s great, because you can easily compare two handles or even use them as table keys. You also don&amp;rsquo;t waste your memory, but that&amp;rsquo;s not a big concern as our handles are very light.&lt;/p>
&lt;p>If you want to remove and recreate some entity, you&amp;rsquo;ll just have to notify the main Lua handle which will be stored inside some global Lua table. And because all your handles in Lua will be references to original handle you won&amp;rsquo;t have to care about them: once you update the main handle, it&amp;rsquo;s updated everywhere.&lt;/p>
&lt;p>Another good thing is that once the entity is removed, we can just set &lt;code>isValid&lt;/code> to &lt;code>false&lt;/code> and raw reference to &lt;code>nil&lt;/code> just to be extra safe.&lt;/p>
&lt;p>Let&amp;rsquo;s get to implementation! We&amp;rsquo;ll use &lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;a href="https://github.com/ThePhD/sol2">sol2&lt;/a> as our Lua/C++ binding library. Let&amp;rsquo;s write a simple &lt;code>Entity&lt;/code> and &lt;code>EntityManager&lt;/code> classes for testing:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">using&lt;/span> EntityId &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span>;
&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="color:#458;font-weight:bold">Entity&lt;/span> {
&lt;span style="font-weight:bold">public&lt;/span>&lt;span style="font-weight:bold">:&lt;/span>
&lt;span style="font-weight:bold">explicit&lt;/span> Entity(EntityId id) &lt;span style="font-weight:bold">:&lt;/span>
name(&lt;span style="color:#b84">&amp;#34;John&amp;#34;&lt;/span>), id(id)
{}
&lt;span style="font-weight:bold">const&lt;/span> std&lt;span style="font-weight:bold">::&lt;/span>string&lt;span style="font-weight:bold">&amp;amp;&lt;/span> getName() &lt;span style="font-weight:bold">const&lt;/span> { &lt;span style="font-weight:bold">return&lt;/span> name; }
&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">setName&lt;/span>(&lt;span style="font-weight:bold">const&lt;/span> std&lt;span style="font-weight:bold">::&lt;/span>string&lt;span style="font-weight:bold">&amp;amp;&lt;/span> n) { name &lt;span style="font-weight:bold">=&lt;/span> n; }
EntityId &lt;span style="color:#900;font-weight:bold">getId&lt;/span>() &lt;span style="font-weight:bold">const&lt;/span> { &lt;span style="font-weight:bold">return&lt;/span> id; }
&lt;span style="font-weight:bold">private&lt;/span>&lt;span style="font-weight:bold">:&lt;/span>
std&lt;span style="font-weight:bold">::&lt;/span>string name;
EntityId id;
};
sol&lt;span style="font-weight:bold">::&lt;/span>state lua; &lt;span style="color:#998;font-style:italic">// globals are bad, but we&amp;#39;ll use it for simpler implementation
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>
&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="color:#458;font-weight:bold">EntityManager&lt;/span> {
&lt;span style="font-weight:bold">public&lt;/span>&lt;span style="font-weight:bold">:&lt;/span>
EntityManager() &lt;span style="font-weight:bold">:&lt;/span> idCounter(&lt;span style="color:#099">0&lt;/span>) {}
Entity&lt;span style="font-weight:bold">&amp;amp;&lt;/span> createEntity()
{
&lt;span style="font-weight:bold">auto&lt;/span> id &lt;span style="font-weight:bold">=&lt;/span> idCounter;
&lt;span style="font-weight:bold">++&lt;/span>idCounter;
&lt;span style="font-weight:bold">auto&lt;/span> inserted &lt;span style="font-weight:bold">=&lt;/span> entities.emplace(id, std&lt;span style="font-weight:bold">::&lt;/span>make_unique&lt;span style="font-weight:bold">&amp;lt;&lt;/span>Entity&lt;span style="font-weight:bold">&amp;gt;&lt;/span>(id));
&lt;span style="font-weight:bold">auto&lt;/span> it &lt;span style="font-weight:bold">=&lt;/span> inserted.first; &lt;span style="color:#998;font-style:italic">// iterator to created id/Entity pair
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="font-weight:bold">auto&lt;/span>&lt;span style="font-weight:bold">&amp;amp;&lt;/span> e &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">*&lt;/span>it&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>second; &lt;span style="color:#998;font-style:italic">// created entity
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span> lua[&lt;span style="color:#b84">&amp;#34;createHandle&amp;#34;&lt;/span>](e);
&lt;span style="font-weight:bold">return&lt;/span> e;
}
&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">removeEntity&lt;/span>(EntityId id)
{
lua[&lt;span style="color:#b84">&amp;#34;onEntityRemoved&amp;#34;&lt;/span>](id);
entities.erase(id);
}
&lt;span style="font-weight:bold">private&lt;/span>&lt;span style="font-weight:bold">:&lt;/span>
std&lt;span style="font-weight:bold">::&lt;/span>unordered_map&lt;span style="font-weight:bold">&amp;lt;&lt;/span>EntityId, std&lt;span style="font-weight:bold">::&lt;/span>unique_ptr&lt;span style="font-weight:bold">&amp;lt;&lt;/span>Entity&lt;span style="font-weight:bold">&amp;gt;&amp;gt;&lt;/span> entities;
EntityId idCounter;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here&amp;rsquo;s how we will create our handle in Lua:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">createHandle&lt;/span>(cppRef)
&lt;span style="font-weight:bold">local&lt;/span> handle &lt;span style="font-weight:bold">=&lt;/span> {
cppRef &lt;span style="font-weight:bold">=&lt;/span> cppRef,
isValid &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">true&lt;/span>
}
setmetatable(handle, mt)
Handles[cppRef:getId()] &lt;span style="font-weight:bold">=&lt;/span> handle
&lt;span style="font-weight:bold">return&lt;/span> handle
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>Handles&lt;/code> global table stores all handles so that we can easily get them later. As you can see, we still use integer ids for it as a tables key so that when we remove an entity, we can easily find its handle and modify it appropriately.&lt;/p>
&lt;p>The metatable has an important function: it will let us use the handle as if it was the original reference. Here&amp;rsquo;s how it&amp;rsquo;s written:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">local&lt;/span> mt &lt;span style="font-weight:bold">=&lt;/span> { }
mt.__index &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(handle, key)
&lt;span style="font-weight:bold">if&lt;/span> &lt;span style="font-weight:bold">not&lt;/span> handle.isValid &lt;span style="font-weight:bold">then&lt;/span>
print(debug.traceback())
error(&lt;span style="color:#b84">&amp;#34;Error: handle is not valid!&amp;#34;&lt;/span>, &lt;span style="color:#099">2&lt;/span>)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(handle, ...) &lt;span style="font-weight:bold">return&lt;/span> Entity[key](handle.cppRef, ...) &lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Just a quick reminder: metatable&amp;rsquo;s &lt;code>__index&lt;/code> function gets called when the key in the table is not found and the table (our handle) and missing key are passed.&lt;/p>
&lt;p>Here&amp;rsquo;s an example of how it all works. When we do this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">handle:setName(&lt;span style="color:#b84">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lua checks if handle table has &amp;ldquo;setName&amp;rdquo; key, but it doesn&amp;rsquo;t, so it calls metatable&amp;rsquo;s &lt;code>__index&lt;/code> function with handle and &amp;ldquo;John&amp;rdquo; as parameters. The wrapper around &lt;code>Entity&lt;/code>&amp;rsquo;s member function is returned and it gets called. The function which gets returned is a closure which calls the &lt;code>Entity&lt;/code>&amp;rsquo;s class member function on original raw reference. Why can&amp;rsquo;t we just return &lt;code>Entity[key]&lt;/code>? The problem with that is that our handle will get passed into it while the function expects raw reference to be passed (&lt;code>cppRef:setName(&amp;quot;John&amp;quot;)&lt;/code> is the same as calling &lt;code>Entity.setName(cppRef, &amp;quot;John&amp;quot;)&lt;/code>).&lt;/p>
&lt;p>The error checking that we have here is extremely important and useful! It allows us to easily debug problems with our code: we even print the call stack to find the place where our code crashed!&lt;/p>
&lt;blockquote class="hint-info">
Notice that we pass &amp;ldquo;2&amp;rdquo; as the second argument in &lt;code>error&lt;/code> function. It tells it that the problem is not the function which called it, the bad one was below it in a call stack.
&lt;/blockquote>
&lt;p>Another great thing about this implementation is that it lets us handle error on Lua side, not C++ side. Once the C++ function is called from Lua, it&amp;rsquo;s hard to properly throw and catch an error from C++. You&amp;rsquo;ll have to compile Lua as C++ to do it without a crash. Throwing the error before calling C++ allows us to safely catch it on Lua side and handle it appropriately. We&amp;rsquo;ll see how it can be done a bit later.&lt;/p>
&lt;p>Let&amp;rsquo;s test out reference first:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">test&lt;/span>(cppRef)
&lt;span style="font-weight:bold">local&lt;/span> handle &lt;span style="font-weight:bold">=&lt;/span> createHandle(cppRef)
testHandle(handle)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">testHandle&lt;/span>(handle)
print(&lt;span style="color:#b84">&amp;#34;Hello, my name is &amp;#34;&lt;/span> &lt;span style="font-weight:bold">..&lt;/span> handle:getName())
handle:setName(&lt;span style="color:#b84">&amp;#34;Mark&amp;#34;&lt;/span>)
print(&lt;span style="color:#b84">&amp;#34;My name is &amp;#34;&lt;/span> &lt;span style="font-weight:bold">..&lt;/span> handle:getName() &lt;span style="font-weight:bold">..&lt;/span> &lt;span style="color:#b84">&amp;#34; now!&amp;#34;&lt;/span>)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Output:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>It works! What should we do when entity gets removed? Let&amp;rsquo;s create a function for that:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">onEntityRemoved&lt;/span>(id)
&lt;span style="font-weight:bold">local&lt;/span> handle &lt;span style="font-weight:bold">=&lt;/span> Handles[id];
handle.cppRef &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">nil&lt;/span>
handle.isValid &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">false&lt;/span>
Handles[id] &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">nil&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We need to call it before our entity gets removed and you can place it into &lt;code>Entity&lt;/code>&amp;rsquo;s destructor or into &lt;code>EntityManager&lt;/code>&amp;rsquo;s &lt;code>removeEntity&lt;/code> function. Note, that this doesn&amp;rsquo;t remove the handle itself: someone may still be referencing it, but setting corresponding value in &lt;code>Handles&lt;/code> table to &lt;code>nil&lt;/code> is still useful because if someone tries to grab a handle later, &lt;code>nil&lt;/code> will be returned. What&amp;rsquo;s more important is that &lt;code>isValid&lt;/code> is set to false so that the next time someone tries to use the handle, the error will be raised.&lt;/p>
&lt;p>Now let&amp;rsquo;s see what happens when we try to use invalid reference. We can even do our error handling in Lua now!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">testBadReference&lt;/span>()
&lt;span style="font-weight:bold">local&lt;/span> handle &lt;span style="font-weight:bold">=&lt;/span> Handles[&lt;span style="color:#099">0&lt;/span>] &lt;span style="color:#998;font-style:italic">-- this handle exists and is okay&lt;/span>
handle.isValid &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">false&lt;/span> &lt;span style="color:#998;font-style:italic">-- but suppose that entity was removed!&lt;/span>
&lt;span style="font-weight:bold">local&lt;/span> _, err &lt;span style="font-weight:bold">=&lt;/span> pcall(testHandle, handle)
&lt;span style="font-weight:bold">if&lt;/span> err &lt;span style="font-weight:bold">then&lt;/span>
print(err)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When we call this function from C++ we don&amp;rsquo;t get a crash which would have been caused by using stale reference. Instead, we get a helpful error message and call stack:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">stack traceback:
script.lua:23: in &lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#b84">&amp;#39;getName&amp;#39;&lt;/span>
script.lua:57: in &lt;span style="font-weight:bold">function&lt;/span> &amp;lt;script.lua:56&amp;gt;
&lt;span style="font-weight:bold">[&lt;/span>C&lt;span style="font-weight:bold">]&lt;/span>: in &lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#b84">&amp;#39;pcall&amp;#39;&lt;/span>
script.lua:65: in &lt;span style="font-weight:bold">function&lt;/span> &amp;lt;script.lua:62&amp;gt;
script.lua:57: Error: handle is not valid!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>What about the performance? My tests show that it&amp;rsquo;s around &lt;strong>600 nanoseconds&lt;/strong> per C++ member function call. It&amp;rsquo;s not that bad, but still may be not good enough for some people. In that case it&amp;rsquo;s easy to get a raw reference and then use it without any additional overhead of error checking:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">local&lt;/span> rawRef &lt;span style="font-weight:bold">=&lt;/span> handle.cppRef
print(&lt;span style="color:#b84">&amp;#34;Raw reference used. Name: &amp;#34;&lt;/span> &lt;span style="font-weight:bold">..&lt;/span> rawRef:getName())
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can also speed up &lt;code>__index&lt;/code> function. I&amp;rsquo;ve found that its biggest overhead is creating a closure every time&amp;hellip; so let&amp;rsquo;s memoize our wrapper functions! First of all, we&amp;rsquo;ll create a table which will store our wrapper functions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">local&lt;/span> memoizedFuncs &lt;span style="font-weight:bold">=&lt;/span> {}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then we change our &lt;code>__index&lt;/code> method to this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">mt.__index &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(handle, key)
&lt;span style="font-weight:bold">if&lt;/span> &lt;span style="font-weight:bold">not&lt;/span> handle.isValid &lt;span style="font-weight:bold">then&lt;/span>
print(debug.traceback())
error(&lt;span style="color:#b84">&amp;#34;Error: handle is not valid!&amp;#34;&lt;/span>, &lt;span style="color:#099">2&lt;/span>)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">local&lt;/span> f &lt;span style="font-weight:bold">=&lt;/span> memoizedFuncs[key]
&lt;span style="font-weight:bold">if&lt;/span> &lt;span style="font-weight:bold">not&lt;/span> f &lt;span style="font-weight:bold">then&lt;/span>
f &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(handle, ...) &lt;span style="font-weight:bold">return&lt;/span> Entity[key](handle.cppRef, ...) &lt;span style="font-weight:bold">end&lt;/span>
memoizedFuncs[key] &lt;span style="font-weight:bold">=&lt;/span> f
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">return&lt;/span> f
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The closure for each function will be created once and then will get reused. This speeds up things considerably! The overhead is roughly &lt;strong>200 nanoseconds&lt;/strong> per call.&lt;/p>
&lt;p>What else? Calling the function through &lt;code>__index&lt;/code> produces additional overhead too. Suppose that we use &lt;code>getName&lt;/code> function very often and want it to be part of our handle table so that it&amp;rsquo;s called directly. Ok, let&amp;rsquo;s do this!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">createHandle&lt;/span>(cppRef)
&lt;span style="font-weight:bold">local&lt;/span> handle &lt;span style="font-weight:bold">=&lt;/span> {
cppRef &lt;span style="font-weight:bold">=&lt;/span> cppRef,
isValid &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">true&lt;/span>
}
handle.getName &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(handle, ...)
&lt;span style="font-weight:bold">return&lt;/span> Entity.getName(handle.cppRef, ...)
&lt;span style="font-weight:bold">end&lt;/span>
setmetatable(handle, mt)
Handles[cppRef:getId()] &lt;span style="font-weight:bold">=&lt;/span> handle
&lt;span style="font-weight:bold">return&lt;/span> handle
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Wait a second&amp;hellip; what happens when we call getName on bad handle? There&amp;rsquo;s no error checking! Let&amp;rsquo;s fix that:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">&lt;span style="font-weight:bold">function&lt;/span> &lt;span style="color:#900;font-weight:bold">getWrappedSafeFunction&lt;/span>(f)
&lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(handle, ...)
&lt;span style="font-weight:bold">if&lt;/span> &lt;span style="font-weight:bold">not&lt;/span> handle.isValid &lt;span style="font-weight:bold">then&lt;/span>
print(debug.traceback())
error(&lt;span style="color:#b84">&amp;#34;Error: handle is not valid!&amp;#34;&lt;/span>, &lt;span style="color:#099">2&lt;/span>)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">return&lt;/span> f(handle.cppRef, ...)
&lt;span style="font-weight:bold">end&lt;/span>
&lt;span style="font-weight:bold">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and then in createHandle we&amp;rsquo;ll write:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">handle.getName &lt;span style="font-weight:bold">=&lt;/span> getWrappedSafeFunction(Entity.getName)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the overhead is just &lt;strong>70 nanoseconds&lt;/strong>. The only added overhead is additional function call, validity check and retrieval of raw reference from handle table, but I think it&amp;rsquo;s pretty small for gained benefits.&lt;/p></description></item><item><title>Re:creation dev log. July - November 2016</title><link>https://eliasdaler.github.io/hugo-test/posts/re-creation-devlog-july-november2016/</link><pubDate>Sun, 27 Nov 2016 15:00:00 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/re-creation-devlog-july-november2016/</guid><description>&lt;p>The last five months were really important for the game. It finally feels like I can work on the game itself now, not just the engine and basic systems which will let me implement different stuff in the game. It&amp;rsquo;s not just abstract stuff, stuff which I do &amp;ldquo;just in case&amp;rdquo;. No, I try to be pragmatic and implement things which are needed for the game and which will let me create stuff without much restrictions.&lt;/p>
&lt;p>I&amp;rsquo;m very glad to say this, but I feel like the core engine is almost done. There are still some important things which I&amp;rsquo;ll have to implement, but it still feels like I&amp;rsquo;m finally happy with the design I have. Mostly, it&amp;rsquo;s because I&amp;rsquo;ve removed lots of stuff and find lots of ways to minimize my code which in the end gives me ability to implement new stuff easier and makes the whole thing easier to expand, modify and debug.&lt;/p>
&lt;p>I&amp;rsquo;m finally ready to do a lot of prototyping. I&amp;rsquo;ve already done a lot of stuff about the game, but I still have the feeling that it&amp;rsquo;s just the beginning of the &amp;ldquo;real&amp;rdquo; development! And it feels great, because I feel like I&amp;rsquo;m in total control of every aspect of the game. There are no restrictions, no boundaries. Let&amp;rsquo;s see how it goes.&lt;/p>
&lt;p>One more small thing: I&amp;rsquo;ve got a new laptop! I&amp;rsquo;ve had it for two weeks now. It feels really great. I&amp;rsquo;m able to do stuff a lot quicker and without frustration (having a great mood is important to be productive)! I&amp;rsquo;ve had my previous laptop for six years and it was slowing me down a lot. It was constantly overheating, everything was running poorly, compilation took a long time, etc&amp;hellip; And recently I&amp;rsquo;ve realized how much it hurt my working process. There were lots of distractions, because even small change could take 1-2 minutes of recompilation. This means, that fast iteration was impossible. This also means that I constantly lost flow and couldn&amp;rsquo;t debug quickly. Hours of slow progress made it all exhausting. Won&amp;rsquo;t happen anymore!&lt;/p>
&lt;p>Okay, let&amp;rsquo;s begin!&lt;/p>
&lt;h1 id="art">Art&lt;/h1>
&lt;p>I haven&amp;rsquo;t done much art in the last months and most of the stuff I&amp;rsquo;ve done is still not finished, so I&amp;rsquo;ll show them a bit later. There&amp;rsquo;s a next graphics improvement coming and I&amp;rsquo;m glad that I didn&amp;rsquo;t have a lot of graphics done, because I&amp;rsquo;d have to redraw tons of stuff. Let&amp;rsquo;s hope it will be the last huge change!&lt;/p>
&lt;p>I&amp;rsquo;ve improved Renatus' design and walking animation, it&amp;rsquo;s nice to see how much my art improved over time:
&lt;img src="walk-animations.gif" alt="Re:cration walk cycles">&lt;/p>
&lt;p>I&amp;rsquo;ve also made some very small, but cool things&amp;hellip;
Unsynched idle animations make everything look more alive!
&lt;img src="torches.gif" alt="Torches">&lt;/p>
&lt;p>Cat doesn&amp;rsquo;t &amp;ldquo;talk&amp;rdquo; during &amp;ldquo;translation&amp;rdquo;
&lt;img src="cat-talk.gif" alt="Cat speaking">&lt;/p>
&lt;h1 id="multiple-tilemaps-in-one-level">Multiple tilemaps in one level&lt;/h1>
&lt;p>Previously the level was limited to one tile map. That meant that if I wanted to make indoor places I either had to switch to another level (which isn&amp;rsquo;t fast!) or place the indoor area somewhere far away and teleport the player there. The second approach is highly used in 3d games, but I&amp;rsquo;ve realized that it wasn&amp;rsquo;t as good in 2d tile-based games because it&amp;rsquo;s harder to move tiles and you have to account for empty areas in your tilemap which are created by placing some area far away.&lt;/p>
&lt;p>Eventually, I&amp;rsquo;ve made a decision to make levels which support multiple tilemaps. It wasn&amp;rsquo;t easy to make, because lots of assumptions were made about Level having only one tilemap, but fortunately it wasn&amp;rsquo;t that bad, so I&amp;rsquo;ve done it fairly quickly. Now I can easily switch tilemaps during the fade in / fade out effect during scene transitions.&lt;/p>
&lt;h1 id="input">Input&lt;/h1>
&lt;p>Previously I&amp;rsquo;ve used polling for input, but realized that events are a lot more efficient and let me easily move all the input in Lua! One more part of game logic moved from C++ to Lua again! Great.&lt;/p>
&lt;p>I&amp;rsquo;ve also made much better system for input in general. Now all keys can be mapped to &amp;ldquo;actions&amp;rdquo; or &amp;ldquo;axes&amp;rdquo; (plural of &amp;ldquo;axis&amp;rdquo;, not &amp;ldquo;axe&amp;rdquo;!). &amp;ldquo;Actions&amp;rdquo; and &amp;ldquo;Axes&amp;rdquo; can be binded to C++ or Lua callback. This makes low-level input decoupled from game input logic in a nice way.&lt;/p>
&lt;p>One advantage of event based scripting is being able to set only one callback for particular action at given time. For example, during dialogues the &amp;ldquo;Primary Action&amp;rdquo; input action will be assigned to &amp;ldquo;Skip dialogue&amp;rdquo;, not &amp;ldquo;Attack/Use Primary Item&amp;rdquo;, so I don&amp;rsquo;t have to worry that somehow the player will be able to attack during dialogues.&lt;/p>
&lt;p>My input manager now also has complete gamepad support (sticks and triggers are also supported and it&amp;rsquo;s possible to connect gamepad in-game!). Event based input will later make it easy to implement replay system which will just send input events at needed times, simulating real player pressing buttons. Easy to implement and very useful for debugging!&lt;/p>
&lt;h1 id="moved-entity-states-from-c-to-lua">Moved Entity states from C++ to Lua&lt;/h1>
&lt;p>This is a thing that I wanted to make for a long time. Basically, most of the game logic lives in entity states. State like &lt;code>MoveState&lt;/code>, &lt;code>AttackState&lt;/code>, etc. Previously they were hard-coded in C++ which made them hard to modify and control with Lua. Another problem was that the more stuff I added to Lua, the harder it became for me to access stuff one Lua side.&lt;/p>
&lt;p>For example, once I&amp;rsquo;ve implemented Action Lists in Lua, I&amp;rsquo;ve realized that some entity states can highly benefit from using them. But this meant that a lot of calls between Lua and C++ would happen.&lt;/p>
&lt;p>Rewriting entity states was extremely easy and I&amp;rsquo;ve discovered and fixed a lot of bugs along the way. I&amp;rsquo;ve also made entity states a lot more reusable, so that different entities can use the same code while adding bits that are different. For example, the same AttackState is used by player character, enemies with melee weapons and archers!&lt;/p>
&lt;p>Action lists are used to make code much easier to follow, basically the lists goes like this:&lt;/p>
&lt;ul>
&lt;li>Pre-attack animation (starting to swing a sword / aiming the arrow)&lt;/li>
&lt;li>Attack animation (continuing to swing a sword / shooting the arrow)
During this step the damage is created during some frame. For melee attackers it&amp;rsquo;s defined in their AttackComponent, for archer the damage is &amp;ldquo;arrow&amp;rdquo; entity which is created on the first frame of &amp;ldquo;shoot&amp;rdquo; animation&lt;/li>
&lt;li>Post attack animation&lt;/li>
&lt;/ul>
&lt;p>I&amp;rsquo;ve also implemented multiple state machines for entities. Most of the time the entity will have only one state machine which will describe it&amp;rsquo;s &amp;ldquo;main&amp;rdquo; state, but sometimes it&amp;rsquo;s useful to have another state machine which will, for example, describe it&amp;rsquo;s health state, so that if the entity has low health, it will play different &amp;ldquo;idle&amp;rdquo; animation.&lt;/p>
&lt;h1 id="private-messages-in-event-system">Private messages in event system&lt;/h1>
&lt;p>I&amp;rsquo;ve effectively used event system with global queue for quite some time, but then I&amp;rsquo;ve realized that it&amp;rsquo;s not efficient for some events to be implemented that way. One example of this is collision callbacks. When two entities collide, each entity&amp;rsquo;s onCollide function needs to be called with some additional info about which entity collided with it and maybe how it happened. In global queue each entity interested in collision event would receive this event and it would have to check if the collision happened with it or not. Of course that&amp;rsquo;s a huge waste of time, so that&amp;rsquo;s why I&amp;rsquo;ve made &amp;ldquo;private message&amp;rdquo; system which let&amp;rsquo;s entities specify sender and receiver for each event and then EventManager just sends this event to receiver object.&lt;/p>
&lt;h1 id="improved-dialogues-a-lot">Improved dialogues a lot&lt;/h1>
&lt;p>Dialogue system got some needed improvements! One such improvement is ability to insert delays and even function calls between words! It looks like this in a text:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{&lt;span style="color:#000080">&amp;#34;SOME_TEXT_TAG&amp;#34;&lt;/span> : &lt;span style="color:#b84">&amp;#34;Hello...[DELAY 500][X] I&amp;#39;ve been waiting for you&amp;#34;&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>[DELAY 500]&lt;/code> creates a 500 ms delay. &lt;code>[X]&lt;/code> indicates that the function with tag &amp;ldquo;X&amp;rdquo; will be called. In scripts, it looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-lua" data-lang="lua">DialogueAction {
text &lt;span style="font-weight:bold">=&lt;/span> {&lt;span style="color:#b84">&amp;#34;SOME_TEXT_TAG&amp;#34;&lt;/span>},
functions &lt;span style="font-weight:bold">=&lt;/span> {
x &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">function&lt;/span>(talker)
talker:setAnimation(&lt;span style="color:#b84">&amp;#34;smile&amp;#34;&lt;/span>)
&lt;span style="font-weight:bold">end&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I later plan to add shaking or wave effects to text for better expression of characters' emotions.&lt;/p>
&lt;h1 id="dev-tools">Dev tools&lt;/h1>
&lt;p>I&amp;rsquo;ve made some useful in-game dev tools with ImGui. One such tool is in-game console which lets me execute Lua easily. Here&amp;rsquo;s a little demo of it in action!
&lt;img src="lua-console.gif" alt="Lua console">&lt;/p>
&lt;p>I&amp;rsquo;ve also made a tool for controlling time. Now it&amp;rsquo;s possible to slow down and pause the game at any moment. The game doesn&amp;rsquo;t slow down or stop, I just change deltaTime, so I can easily debug everything in Visual Studio.
&lt;img src="time-control.gif" alt="Time control">&lt;/p>
&lt;h1 id="removed-tons-of-components">Removed tons of components&lt;/h1>
&lt;p>I&amp;rsquo;ve also removed a lot of components which I found redundant and easily made with other components which have much larger role. Here&amp;rsquo;s what I&amp;rsquo;ve removed.&lt;/p>
&lt;h2 id="direction-component">Direction Component&lt;/h2>
&lt;p>Direction component stored just one thing: entity&amp;rsquo;s direction. But that meant that to access entity&amp;rsquo;s direction I had to get DirectionComponent and then get the direction. Getting component from entity isn&amp;rsquo;t very fast (because it involves a &lt;code>dynamic_cast&lt;/code> and &lt;code>std::unordered_map&lt;/code> search) so I&amp;rsquo;ve just started to store entity&amp;rsquo;s direction in Entity class. Yes, some entities won&amp;rsquo;t have a direction (invisible entities or trees, for example), but I just assign &lt;code>Direction::None&lt;/code> to them. Storing 1 additional byte inside of Entity isn&amp;rsquo;t a big deal!&lt;/p>
&lt;h2 id="trigger-component">Trigger Component&lt;/h2>
&lt;p>I&amp;rsquo;ve also removed trigger component. Previously it was used for triggers and made possible to realize the following callbacks: &lt;code>onEnter&lt;/code>, &lt;code>onStay&lt;/code> and &lt;code>onExit&lt;/code>. But how did I check when to call them? I checked if trigger collides with potentially interesting entities or not&amp;hellip; but then I&amp;rsquo;ve realized: why not just use &lt;code>CollisionComponent&lt;/code> for that and make a simple entity state machine which will track entities state which are: Idle or Triggered. OnEnter is called on transition from Idle to Triggered state, onStay is called when Triggered state is active and onExit is called during transition from Triggered to Idle state. &lt;code>CollisionEnter&lt;/code> and &lt;code>CollisionExit&lt;/code> events trigger state transitions. This means that TriggerComponent wasn&amp;rsquo;t needed anymore and I got rid of it with a huge satisfaction.&lt;/p>
&lt;p>I&amp;rsquo;ve also made &amp;ldquo;directed&amp;rdquo; triggers which are called only when the player faces the specific direction, for example cafe has a trigger which lets player exit it when his direction is &amp;ldquo;Down&amp;rdquo;.&lt;/p>
&lt;h2 id="interaction-component">Interaction Component&lt;/h2>
&lt;p>Interaction Component was used for player-entity interactions, for example speaking with NPCs. When the player enters the &amp;ldquo;interaction area&amp;rdquo;, the input changes and pressing a specific button will start dialogue. Hmmm&amp;hellip; seems familiar, isn&amp;rsquo;t it? Yes, this component isn&amp;rsquo;t needed too, because I can just make a trigger which will just change the input during onEnter/onExit function calls. Using it with &amp;ldquo;directed&amp;rdquo; triggers makes it perfect, because now it&amp;rsquo;s easy to make interaction possible only when the player faces the entity. (Previously it was possible to talk with NPCs while turning away from them, not cool!)&lt;/p>
&lt;h1 id="remade-damage-system">Remade damage system&lt;/h1>
&lt;p>Previously when player attacked, the &amp;ldquo;damage&amp;rdquo; entity was created and then destroyed. If something collided with it, the damage was registered. But on one random forum I&amp;rsquo;ve found much better solution: just have &amp;ldquo;damage&amp;rdquo; rect with melee attackers all the time and activate it only during attack. Simple and much more efficient!&lt;/p>
&lt;h1 id="sat-separating-axis-theorem-collision">SAT (Separating Axis Theorem) collision&lt;/h1>
&lt;p>After a lot of trying and failing, I&amp;rsquo;ve implemented SAT collision detection and response which will be used for some complex level geometry.
&lt;img src="sat.gif" alt="SAT in action">&lt;/p>
&lt;p>I&amp;rsquo;ve put my SAT implementation &lt;a href="https://gist.github.com/eliasdaler/502b54fcf1b515bcc50360ce874e81bc">here&lt;/a>. Feel free to use it for your projects!&lt;/p>
&lt;h1 id="refactoring">Refactoring&lt;/h1>
&lt;p>I&amp;rsquo;ve also done &lt;strong>a lot&lt;/strong> of refactoring. I&amp;rsquo;m mostly satisfied with most of my codebase, but there was some bad stuff that I needed to fix once and for all!
Mostly, I&amp;rsquo;ve been fixing pretty typical problems: unnecessary dependencies, some code duplication, problems with ownerships, etc. Not too much to say about that!
But the good thing about refactoring is that it just made my codebase a lot shorter. At some point it&amp;rsquo;s not a refactoring anymore, it&amp;rsquo;s restructuring, implementing better code, moving some stuff to Lua, etc.&lt;/p>
&lt;p>&lt;strong>C++&lt;/strong>: -4345 lines of code&lt;/p>
&lt;p>&lt;strong>Lua&lt;/strong>: +540 lines of code&lt;/p>
&lt;p>&lt;strong>Total&lt;/strong>: -3814 lines of code&lt;/p>
&lt;p>This makes me extremely happy, because shorter and cleaner code is much easier to manage and improve. Writing negative code feels great!&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>The last few months were very important and productive! While there wasn&amp;rsquo;t a huge progress about the game itself, the engine is almost done, I&amp;rsquo;m very happy with the code and engine structure now. The next few months will be spent prototyping and making &amp;ldquo;vertical slice&amp;rdquo; of the game and I hope I&amp;rsquo;ll be able to make game truly fun and enjoyable. See ya!&lt;/p></description></item><item><title>Using Dear ImGui with modern C++ and STL for creating awesome game dev tools</title><link>https://eliasdaler.github.io/hugo-test/posts/using-imgui-with-sfml-pt-2/</link><pubDate>Thu, 21 Jul 2016 20:34:00 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/using-imgui-with-sfml-pt-2/</guid><description>&lt;p>Related article: &lt;a href="https://eliasdaler.github.io/hugo-test/posts/using-imgui-with-sfml-pt-1/">Using Dear ImGui with SFML for creating awesome game dev tools&lt;/a>&lt;/p>
&lt;hr>
&lt;p>This is my second article about Dear ImGui! This article is a collection of useful things, hacks and other stuff I&amp;rsquo;ve found while using ImGui. Mostly it&amp;rsquo;s focused on using modern C++ and some parts of STL with ImGui.&lt;/p>
&lt;figure>&lt;img src="imgui-widgets.png"/>&lt;figcaption>
&lt;h4>Different Dear ImGui widgets&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;div>
&lt;h2>Table Of Contents&lt;/h2>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#labels">Labels&lt;/a>&lt;/li>
&lt;li>&lt;a href="#getting-back-to-the-context-of-the-window-tree-etc">Getting back to the context of the window, tree, etc.&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inputfloatn--struct">InputFloatN + struct&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-imgui-with-stl">Using ImGui with STL&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#arrays">Arrays&lt;/a>&lt;/li>
&lt;li>&lt;a href="#combobox-listbox">ComboBox, ListBox&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inputtext-and-stdstring">InputText and std::string&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/div>
&lt;h2 id="labels">Labels&lt;/h2>
&lt;p>Labels are used in ImGui as unique IDs for widgets. You shouldn&amp;rsquo;t use same labels for two different widgets as it will introduce collisions between widgets and that will lead to some unwanted behavior.&lt;/p>
&lt;p>Suppose you have two buttons with label &amp;ldquo;Meow&amp;rdquo; and you have a code like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>Button(&lt;span style="color:#b84">&amp;#34;Meow&amp;#34;&lt;/span>)) {
std&lt;span style="font-weight:bold">::&lt;/span>cout &lt;span style="font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#b84">&amp;#34;Meow&lt;/span>&lt;span style="color:#b84">\n&lt;/span>&lt;span style="color:#b84">&amp;#34;&lt;/span>;
}
&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>Button(&lt;span style="color:#b84">&amp;#34;Meow&amp;#34;&lt;/span>)) {
std&lt;span style="font-weight:bold">::&lt;/span>cout &lt;span style="font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#b84">&amp;#34;Purr&lt;/span>&lt;span style="color:#b84">\n&lt;/span>&lt;span style="color:#b84">&amp;#34;&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first button works as expected, but the second doesn&amp;rsquo;t work at all! These are the things that can happen when collisions occur between IDs. This won&amp;rsquo;t happen most of the time, after all there&amp;rsquo;s mostly no need to place two buttons which say the same thing in one window. But what if you &lt;em>really&lt;/em> need these two &amp;ldquo;Meow&amp;rdquo; buttons? The solution is simple: you just have to add &amp;ldquo;##&amp;rdquo; and some stuff after that to resolve the collision:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>Button(&lt;span style="color:#b84">&amp;#34;Meow&amp;#34;&lt;/span>)) {
std&lt;span style="font-weight:bold">::&lt;/span>cout &lt;span style="font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#b84">&amp;#34;Meow&lt;/span>&lt;span style="color:#b84">\n&lt;/span>&lt;span style="color:#b84">&amp;#34;&lt;/span>;
}
&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>Button(&lt;span style="color:#b84">&amp;#34;Meow##Second&amp;#34;&lt;/span>)) {
std&lt;span style="font-weight:bold">::&lt;/span>cout &lt;span style="font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#b84">&amp;#34;Purr&lt;/span>&lt;span style="color:#b84">\n&lt;/span>&lt;span style="color:#b84">&amp;#34;&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>All the text after &amp;ldquo;##&amp;rdquo; is not displayed and only used to give unique IDs to widgets with same labels.
IDs should be unique in the same scope, so it&amp;rsquo;s okay to have two widgets with the same label in two different windows or have one of them in some tree or list (trees, lists and some other widgets have their own scopes, so collisions won&amp;rsquo;t happen between items in them and other items).&lt;/p>
&lt;p>Let&amp;rsquo;s look at another situation. Suppose you have an array of &lt;code>int&lt;/code>s:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">std&lt;span style="font-weight:bold">::&lt;/span>array&lt;span style="font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>, &lt;span style="color:#099">10&lt;/span>&lt;span style="font-weight:bold">&amp;gt;&lt;/span> arr &lt;span style="font-weight:bold">=&lt;/span> { &lt;span style="color:#099">0&lt;/span> };
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now you want to create a bunch of &lt;code>InputInt&lt;/code> widgets for each array element. &lt;code>ImGui::PushID&lt;/code>/&lt;code>PopID&lt;/code> come to the rescue! You can push &lt;code>int&lt;/code>s, &lt;code>const char*&lt;/code> or &lt;code>void*&lt;/code> as IDs which will be appended to the label of the next created widget (but won&amp;rsquo;t be shown). For example, you can do this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">for&lt;/span> (&lt;span style="color:#458;font-weight:bold">int&lt;/span> i &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#099">0&lt;/span>; i &lt;span style="font-weight:bold">&amp;lt;&lt;/span> arr.size(); &lt;span style="font-weight:bold">++&lt;/span>i) {
ImGui&lt;span style="font-weight:bold">::&lt;/span>PushID(i);
ImGui&lt;span style="font-weight:bold">::&lt;/span>InputInt(&lt;span style="color:#b84">&amp;#34;##&amp;#34;&lt;/span>, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>arr[i]);
ImGui&lt;span style="font-weight:bold">::&lt;/span>PopID();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are some situations where you don&amp;rsquo;t have an &lt;code>int&lt;/code> which you can use as part of ID, for example if you want to use for-ranged loop with the &lt;code>std::array&lt;/code>. In that case, you can use pointers to elements of the array which will be unique:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">for&lt;/span> (&lt;span style="font-weight:bold">auto&lt;/span>&lt;span style="font-weight:bold">&amp;amp;&lt;/span> elem : arr) {
ImGui&lt;span style="font-weight:bold">::&lt;/span>PushID(&lt;span style="font-weight:bold">&amp;amp;&lt;/span>elem);
ImGui&lt;span style="font-weight:bold">::&lt;/span>InputInt(&lt;span style="color:#b84">&amp;#34;##&amp;#34;&lt;/span>, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>elem);
ImGui&lt;span style="font-weight:bold">::&lt;/span>PopID();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="getting-back-to-the-context-of-the-window-tree-etc">Getting back to the context of the window, tree, etc.&lt;/h2>
&lt;p>Suppose that you need to add some stuff to the window you&amp;rsquo;ve created before but you already called &lt;code>ImGui::End&lt;/code>. No problem, just call &lt;code>ImGui::Begin&lt;/code> with the name of the window in which you want to append stuff. Here&amp;rsquo;s an example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">ImGui&lt;span style="font-weight:bold">::&lt;/span>Begin(&lt;span style="color:#b84">&amp;#34;First window&amp;#34;&lt;/span>); &lt;span style="color:#998;font-style:italic">// begin first window
&lt;/span>&lt;span style="color:#998;font-style:italic">// some stuff
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>ImGui&lt;span style="font-weight:bold">::&lt;/span>End();
ImGui&lt;span style="font-weight:bold">::&lt;/span>Begin(&lt;span style="color:#b84">&amp;#34;Another window&amp;#34;&lt;/span>); &lt;span style="color:#998;font-style:italic">// begin second window
&lt;/span>&lt;span style="color:#998;font-style:italic">// some another stuff
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>ImGui&lt;span style="font-weight:bold">::&lt;/span>End();
&lt;span style="color:#998;font-style:italic">// oops, forgot to add some stuff!
&lt;/span>&lt;span style="color:#998;font-style:italic">// let&amp;#39;s go back to the context of the first window
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>ImGui&lt;span style="font-weight:bold">::&lt;/span>Begin(&lt;span style="color:#b84">&amp;#34;First window&amp;#34;&lt;/span>);
&lt;span style="color:#998;font-style:italic">// forgotten stuff
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>ImGui&lt;span style="font-weight:bold">::&lt;/span>End();
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="inputfloatn--struct">InputFloatN + struct&lt;/h2>
&lt;p>Sometimes it&amp;rsquo;s useful to use &lt;code>InputFloat2&lt;/code> or &lt;code>InputFloat4&lt;/code> with your point or rectangle structs which can be defined like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">struct&lt;/span> &lt;span style="color:#458;font-weight:bold">Point&lt;/span> {
&lt;span style="color:#458;font-weight:bold">float&lt;/span> x;
&lt;span style="color:#458;font-weight:bold">float&lt;/span> y;
};
&lt;span style="font-weight:bold">struct&lt;/span> &lt;span style="color:#458;font-weight:bold">Rect&lt;/span> {
&lt;span style="color:#458;font-weight:bold">float&lt;/span> x;
&lt;span style="color:#458;font-weight:bold">float&lt;/span> y;
&lt;span style="color:#458;font-weight:bold">float&lt;/span> w;
&lt;span style="color:#458;font-weight:bold">float&lt;/span> h;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using them with &lt;code>InputFloat2&lt;/code> or &lt;code>InputFloat4&lt;/code> is easy:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">Point p{ &lt;span style="color:#099">0.f&lt;/span>, &lt;span style="color:#099">0.f&lt;/span> };
Rect r{ &lt;span style="color:#099">0.f&lt;/span>, &lt;span style="color:#099">0.f&lt;/span>, &lt;span style="color:#099">0.f&lt;/span>, &lt;span style="color:#099">0.f&lt;/span> };
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">ImGui&lt;span style="font-weight:bold">::&lt;/span>InputFloat2(&lt;span style="color:#b84">&amp;#34;Point&amp;#34;&lt;/span>, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>p.x);
ImGui&lt;span style="font-weight:bold">::&lt;/span>InputFloat4(&lt;span style="color:#b84">&amp;#34;Rect&amp;#34;&lt;/span>, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>r.x);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This works because both &lt;code>Point&lt;/code> and &lt;code>Rect&lt;/code> structs are &lt;a href="http://en.cppreference.com/w/cpp/concept/PODType">POD&lt;/a> and don&amp;rsquo;t have &amp;ldquo;holes&amp;rdquo; in them, so the data they store is contiguous and can be interpreted as array of floats.&lt;/p>
&lt;p>This method is not very safe, of course, so use it at your own risk. Someone can modify the struct and this may break your code which assumed that the floats you want to modify are stored contiguously. Unfortunately, there&amp;rsquo;s no way to pass array of pointers to &lt;code>InputFloat2&lt;/code> or &lt;code>InputFloat4&lt;/code>, but you can easily create your own solution. Let&amp;rsquo;s make a function which creates a widget similar to &lt;code>InputFloat4&lt;/code> and uses members of &lt;code>Rect&lt;/code> struct explicitly:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">namespace&lt;/span> imgui_util {
&lt;span style="color:#458;font-weight:bold">bool&lt;/span> &lt;span style="color:#900;font-weight:bold">InputRect&lt;/span>(&lt;span style="font-weight:bold">const&lt;/span> &lt;span style="color:#458;font-weight:bold">char&lt;/span>&lt;span style="font-weight:bold">*&lt;/span> label, Rect&lt;span style="font-weight:bold">*&lt;/span> rectPtr,
&lt;span style="color:#458;font-weight:bold">int&lt;/span> decimal_precision &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="font-weight:bold">-&lt;/span>&lt;span style="color:#099">1&lt;/span>, ImGuiInputTextFlags extra_flags &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#099">0&lt;/span>)
{
ImGui&lt;span style="font-weight:bold">::&lt;/span>PushID(label);
ImGui&lt;span style="font-weight:bold">::&lt;/span>BeginGroup();
&lt;span style="color:#458;font-weight:bold">bool&lt;/span> valueChanged &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#999">false&lt;/span>;
std&lt;span style="font-weight:bold">::&lt;/span>array&lt;span style="font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#458;font-weight:bold">float&lt;/span>&lt;span style="font-weight:bold">*&lt;/span>, &lt;span style="color:#099">4&lt;/span>&lt;span style="font-weight:bold">&amp;gt;&lt;/span> arr &lt;span style="font-weight:bold">=&lt;/span> { &lt;span style="font-weight:bold">&amp;amp;&lt;/span>rectPtr&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>x, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>rectPtr&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>y,
&lt;span style="font-weight:bold">&amp;amp;&lt;/span>rectPtr&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>w, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>rectPtr&lt;span style="font-weight:bold">-&amp;gt;&lt;/span>h };
&lt;span style="font-weight:bold">for&lt;/span> (&lt;span style="font-weight:bold">auto&lt;/span>&lt;span style="font-weight:bold">&amp;amp;&lt;/span> elem : arr) {
ImGui&lt;span style="font-weight:bold">::&lt;/span>PushID(elem);
ImGui&lt;span style="font-weight:bold">::&lt;/span>PushItemWidth(&lt;span style="color:#099">64.f&lt;/span>);
valueChanged &lt;span style="font-weight:bold">|=&lt;/span> ImGui&lt;span style="font-weight:bold">::&lt;/span>InputFloat(&lt;span style="color:#b84">&amp;#34;##arr&amp;#34;&lt;/span>, elem, &lt;span style="color:#099">0&lt;/span>, &lt;span style="color:#099">0&lt;/span>,
decimal_precision, extra_flags);
ImGui&lt;span style="font-weight:bold">::&lt;/span>PopID();
ImGui&lt;span style="font-weight:bold">::&lt;/span>SameLine();
}
ImGui&lt;span style="font-weight:bold">::&lt;/span>SameLine();
ImGui&lt;span style="font-weight:bold">::&lt;/span>TextUnformatted(label);
ImGui&lt;span style="font-weight:bold">::&lt;/span>EndGroup();
ImGui&lt;span style="font-weight:bold">::&lt;/span>PopID(); &lt;span style="color:#998;font-style:italic">// pop label id;
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>
&lt;span style="font-weight:bold">return&lt;/span> valueChanged;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now you can do this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">imgui_util&lt;span style="font-weight:bold">::&lt;/span>InputRect(&lt;span style="color:#b84">&amp;#34;Rect&amp;#34;&lt;/span>, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>r);
&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="using-imgui-with-stl">Using ImGui with STL&lt;/h2>
&lt;p>There are lots of things to be said about using ImGui with STL. ImGui doesn&amp;rsquo;t use STL at all and users have to pass raw arrays and &lt;code>const char*&lt;/code>s instead of &lt;code>std::vector&lt;/code>s and &lt;code>std::string&lt;/code>s, so you can&amp;rsquo;t just use STL and some modern C++ right away, but it can be done with some work.&lt;/p>
&lt;h3 id="arrays">Arrays&lt;/h3>
&lt;p>Some widgets require you to use raw arrays but those are not the best because you can&amp;rsquo;t use them with algorithms, for ranged loops, etc. And the other problem is that you have to manage the memory of variable size arrays yourself using &lt;code>new&lt;/code> and &lt;code>delete&lt;/code>. Using &lt;code>std::array&lt;/code> with &lt;code>Imgui::InputInt4&lt;/code> which expects you to pass raw array is easy, just do it like this:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">std&lt;span style="font-weight:bold">::&lt;/span>array&lt;span style="font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>, &lt;span style="color:#099">4&lt;/span>&lt;span style="font-weight:bold">&amp;gt;&lt;/span> arr2 &lt;span style="font-weight:bold">=&lt;/span> { &lt;span style="color:#099">0&lt;/span> };
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">ImGui&lt;span style="font-weight:bold">::&lt;/span>InputInt4(&lt;span style="color:#b84">&amp;#34;IntRect&amp;#34;&lt;/span>, arr2.data());
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>std::array::data&lt;/code> returns a pointer to raw int array which can be passed to &lt;code>ImGui::InputInt4&lt;/code>.&lt;/p>
&lt;p>The same can be done with &lt;code>std::vector&lt;/code>s which are guaranteed to be contiguous, so you can just use &lt;code>std::vector::data&lt;/code> the same way:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">std&lt;span style="font-weight:bold">::&lt;/span>vector&lt;span style="font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="font-weight:bold">&amp;gt;&lt;/span> arr3(&lt;span style="color:#099">4&lt;/span>, &lt;span style="color:#099">0&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">ImGui&lt;span style="font-weight:bold">::&lt;/span>InputInt4(&lt;span style="color:#b84">&amp;#34;IntRect&amp;#34;&lt;/span>, arr3.data());
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="combobox-listbox">ComboBox, ListBox&lt;/h3>
&lt;p>&lt;code>ComboBox&lt;/code> and &lt;code>ListBox&lt;/code> can be used with arrays of &lt;code>const char&lt;/code>s, but what if you have &lt;code>std::vector&amp;lt;std::string&amp;gt;&lt;/code> instead? No problem, just use &lt;code>BeginCombo&lt;/code>/&lt;code>EndCombo&lt;/code>/&lt;code>Selectable&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">std&lt;span style="font-weight:bold">::&lt;/span>vector items{&lt;span style="color:#b84">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#b84">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#b84">&amp;#34;c&amp;#34;&lt;/span>}; &lt;span style="color:#998;font-style:italic">// defined somewhere
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> selectedIndex &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#099">0&lt;/span>; &lt;span style="color:#998;font-style:italic">// you need to store this state somewhere
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>
&lt;span style="color:#998;font-style:italic">// later in your code...
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>BeginCombo(&lt;span style="color:#b84">&amp;#34;combo&amp;#34;&lt;/span>)) {
&lt;span style="font-weight:bold">for&lt;/span> (&lt;span style="color:#458;font-weight:bold">int&lt;/span> i &lt;span style="font-weight:bold">=&lt;/span> &lt;span style="color:#099">0&lt;/span>; i &lt;span style="font-weight:bold">&amp;lt;&lt;/span> items.size(); &lt;span style="font-weight:bold">++&lt;/span>i) {
&lt;span style="font-weight:bold">const&lt;/span> &lt;span style="color:#458;font-weight:bold">bool&lt;/span> isSelected &lt;span style="font-weight:bold">=&lt;/span> (selectedIndex &lt;span style="font-weight:bold">==&lt;/span> i);
&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>Selectable(items[i], isSelected)) {
selectedIndex &lt;span style="font-weight:bold">=&lt;/span> i;
}
&lt;span style="color:#998;font-style:italic">// Set the initial focus when opening the combo
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#998;font-style:italic">// (scrolling + keyboard navigation focus)
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> (isSelected) {
ImGui&lt;span style="font-weight:bold">::&lt;/span>SetItemDefaultFocus();
}
}
ImGui&lt;span style="font-weight:bold">::&lt;/span>EndCombo();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="inputtext-and-stdstring">InputText and std::string&lt;/h3>
&lt;p>Dear ImGui lets you pass char array in &lt;code>InputText&lt;/code> and then it modifies it when user enters some text in the input field. The problem is that it&amp;rsquo;s hard to know the size of input in advance, so you have to allocate large enough buffer and then pass it in &lt;code>InputText&lt;/code>.&lt;/p>
&lt;p>However, there&amp;rsquo;s a special overload for &lt;code>InputText&lt;/code> and &lt;code>InputTextMultiline&lt;/code> which allows you to use &lt;code>std::string&lt;/code> with it. You need to include a special header to access it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;lt;misc/cpp/imgui_stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">&lt;/span>
&lt;span style="font-weight:bold">struct&lt;/span> &lt;span style="color:#458;font-weight:bold">Person&lt;/span> {
std&lt;span style="font-weight:bold">::&lt;/span>string name;
};
&lt;span style="color:#998;font-style:italic">// later in code...
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>InputText(&lt;span style="color:#b84">&amp;#34;name&amp;#34;&lt;/span>, &lt;span style="font-weight:bold">&amp;amp;&lt;/span>person.name) { ... }
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Using Dear ImGui with SFML for creating awesome game dev tools</title><link>https://eliasdaler.github.io/hugo-test/posts/using-imgui-with-sfml-pt-1/</link><pubDate>Sun, 10 Jul 2016 15:42:00 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/using-imgui-with-sfml-pt-1/</guid><description>&lt;p>Related article: &lt;a href="https://eliasdaler.github.io/hugo-test/posts/using-imgui-with-sfml-pt-2/">Using ImGui with modern C++ and STL&lt;/a>&lt;/p>
&lt;hr>
&lt;p>This is the first part of tutorial about Dear ImGui (AKA ImGui) and it&amp;rsquo;ll show you how to set it up with SFML. The second part will be library agnostic and will talk about common ways of doing stuff in ImGui, some awesome widgets and some useful STL overloads.&lt;/p>
&lt;figure>&lt;img src="imgui-widgets.png"/>&lt;figcaption>
&lt;h4>Different Dear ImGui widgets&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;div>
&lt;h2>Table Of Contents&lt;/h2>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#introduction">Introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="#dear-imgui-and-immediate-mode-gui-concept">Dear ImGui and immediate mode GUI concept&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-imgui-sfml">Using ImGui-SFML&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#option-a-using-imgui-sfml-with-cmake">Option A. Using ImGui-SFML with CMake&lt;/a>&lt;/li>
&lt;li>&lt;a href="#option-b-using-imgui-sfml-with-vcpkg-and-conan">Option B. Using ImGui-SFML with vcpkg and Conan&lt;/a>&lt;/li>
&lt;li>&lt;a href="#option-c-manual-integration">Option C. Manual integration&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#useful-overloads-for-sfml">Useful overloads for SFML&lt;/a>&lt;/li>
&lt;li>&lt;a href="#conclusion">Conclusion&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/div>
&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Having good content creation (level editor, resource editor, etc.) and debugging
tools for your game is very important and can lead to productivity and
creativity boost. Here are some examples of tools I managed to make with ImGui
for my games.&lt;/p>
&lt;figure>&lt;img src="tomb-painter-dev-tools.png"/>&lt;figcaption>
&lt;h4>Tomb Painter dev tools&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="recreation-level-editor.gif"/>&lt;figcaption>
&lt;h4>Level editor in Re:creation&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="recreation-lua-console.gif"/>&lt;figcaption>
&lt;h4>Lua console&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="recreation-animation-editor.gif"/>&lt;figcaption>
&lt;h4>Animation editor&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>As you can see there&amp;rsquo;s a wide range of widgets that ImGui provides and there are lots of other great examples of how other people use it here.&lt;/p>
&lt;h2 id="dear-imgui-and-immediate-mode-gui-concept">Dear ImGui and immediate mode GUI concept&lt;/h2>
&lt;p>Dear ImGui is an immediate mode GUI library which makes making GUI for all kinds of tools very easy.&lt;/p>
&lt;p>&lt;strong>Immediate mode GUI&lt;/strong> is a bit different to what people think when they hear “GUI” (“retained mode” is a classic way of doing GUI).
Immediate mode GUI is a way of doing GUI which involves creating and drawing widgets in each frame. Instead of creating some &lt;code>Button&lt;/code> object and adding a callback to it, you write something like&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="font-weight:bold">if&lt;/span> (ImGui&lt;span style="font-weight:bold">::&lt;/span>Button(&lt;span style="color:#b84">&amp;#34;Some Button&amp;#34;&lt;/span>)) {
... &lt;span style="color:#998;font-style:italic">// code which will be called on button pressed
&lt;/span>&lt;span style="color:#998;font-style:italic">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Simple as that!&lt;/p>
&lt;p>For a great in-depth talk on this concept, I recommend to check out &lt;a href="https://mollyrocket.com/861">Casey Muratori&amp;rsquo;s talk on IMGUI&lt;/a>.&lt;/p>
&lt;p>Back to Dear ImGui. It&amp;rsquo;s:&lt;/p>
&lt;ul>
&lt;li>MIT Licensed&lt;/li>
&lt;li>Very fast and light&lt;/li>
&lt;li>Constantly updated and expanded&lt;/li>
&lt;li>Doesn&amp;rsquo;t do dynamic allocation/deallocation&lt;/li>
&lt;li>Very portable – has lots of bindings for different libraries and frameworks&lt;/li>
&lt;li>Easily expandable&lt;/li>
&lt;/ul>
&lt;h2 id="using-imgui-sfml">Using ImGui-SFML&lt;/h2>
&lt;p>&lt;a href="https://github.com/eliasdaler/imgui-sfml">ImGui-SFML&lt;/a> is a binding I wrote to
simplify usage of ImGui with SFML. Here&amp;rsquo;s how you can use it.&lt;/p>
&lt;h3 id="option-a-using-imgui-sfml-with-cmake">Option A. Using ImGui-SFML with CMake&lt;/h3>
&lt;blockquote class="hint-info">
You can just see this &lt;a href="https://github.com/eliasdaler/imgui-sfml-fetchcontent">example&lt;/a> of how to use FetchContent to make it easy.
&lt;/blockquote>
&lt;p>First, you need to download Dear ImGui, ImGui-SFML and build SFML somewhere.&lt;/p>
&lt;p>Then, run this where you want to build ImGui-SFML:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">cmake &amp;lt;ImGui-SFML repo folder&amp;gt; -DIMGUI_DIR&lt;span style="font-weight:bold">=&lt;/span>&amp;lt;ImGui repo folder&amp;gt; &lt;span style="color:#b84">\
&lt;/span>&lt;span style="color:#b84">&lt;/span> -DSFML_DIR&lt;span style="font-weight:bold">=&lt;/span>&amp;lt;path with built SFML&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you have SFML installed on your system, you don&amp;rsquo;t need to set SFML_DIR during
configuration.&lt;/p>
&lt;p>You can also specify &lt;code>BUILD_SHARED_LIBS=ON&lt;/code> to build ImGui-SFML as a shared library. To build ImGui-SFML examples, set &lt;code>IMGUI_SFML_BUILD_EXAMPLES=ON&lt;/code>.&lt;/p>
&lt;p>After the building, you can install the library on your system by running:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">cmake --build . --target install
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you set &lt;code>CMAKE_INSTALL_PREFIX&lt;/code> during configuration, you can install ImGui-SFML locally.&lt;/p>
&lt;p>Integrating into your project is simple:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="color:#999">find_package&lt;/span>(&lt;span style="color:#b84">ImGui-SFML&lt;/span> &lt;span style="color:#b84">REQUIRED&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#999">target_link_libraries&lt;/span>(&lt;span style="color:#b84">my_target&lt;/span> &lt;span style="color:#b84">PRIVATE&lt;/span> &lt;span style="color:#b84">ImGui-SFML::ImGui-SFML&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If CMake can&amp;rsquo;t find ImGui-SFML on your system (or you didn&amp;rsquo;t install it), just define &lt;code>ImGui-SFML_DIR&lt;/code> before calling &lt;code>find_package&lt;/code>.&lt;/p>
&lt;h3 id="option-b-using-imgui-sfml-with-vcpkg-and-conan">Option B. Using ImGui-SFML with vcpkg and Conan&lt;/h3>
&lt;blockquote class="hint-warning">
I don&amp;rsquo;t maintain these packages so they might lag behind, so building &lt;code>ImGui-SFML&lt;/code> manually is recommended
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://vcpkg.info/port/imgui-sfml">vcpkg package&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bincrafters.jfrog.io/ui/packages/conan:%2F%2Fimgui-sfml?name=imgui-sfml&amp;amp;type=packages">Conan package&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="option-c-manual-integration">Option C. Manual integration&lt;/h3>
&lt;p>This is slightly more complex&amp;hellip;&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Use SFML to get a simple window to show up. Follow the “Getting started” tutorial &lt;a href="http://www.sfml-dev.org/tutorials/2.3/">here&lt;/a> if you have never done it before.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Download &lt;a href="https://github.com/ocornut/imgui">Dear ImGui&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Download &lt;a href="https://github.com/eliasdaler/imgui-sfml">ImGui-SFML&lt;/a>.&lt;/p>
&lt;p>&lt;strong>Important&lt;/strong>: you have to add the contents of &lt;strong>imconfig-SFML.h&lt;/strong> to ImGui&amp;rsquo;s &lt;strong>imconfig.h&lt;/strong> to get implicit &lt;code>ImVec2&lt;/code> {% icon fa-arrows-h %} &lt;code>sf::Vector2f&lt;/code> conversion working!
{: .message}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Add ImGui and ImGui-SFML directories to your include directories.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Add these files to your build / project:&lt;/p>
&lt;ul>
&lt;li>imgui.cpp&lt;/li>
&lt;li>imgui_draw.cpp&lt;/li>
&lt;li>imgui_widgets.cpp&lt;/li>
&lt;li>imgui-SFML.cpp&lt;/li>
&lt;li>imgui_demo.cpp&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>(Optional) If you get linking errors, link OpenGL to your project.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Here&amp;rsquo;s a complete example of using ImGui and SMFL together.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;#34;imgui.h&amp;#34;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;#34;imgui-SFML.h&amp;#34;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">&lt;/span>
&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;lt;SFML/Graphics/CircleShape.hpp&amp;gt;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;lt;SFML/Graphics/RenderWindow.hpp&amp;gt;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;lt;SFML/System/Clock.hpp&amp;gt;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">#include&lt;/span> &lt;span style="color:#999;font-weight:bold">&amp;lt;SFML/Window/Event.hpp&amp;gt;&lt;/span>&lt;span style="color:#999;font-weight:bold">
&lt;/span>&lt;span style="color:#999;font-weight:bold">&lt;/span>
&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>() {
sf&lt;span style="font-weight:bold">::&lt;/span>RenderWindow window(sf&lt;span style="font-weight:bold">::&lt;/span>VideoMode(&lt;span style="color:#099">640&lt;/span>, &lt;span style="color:#099">480&lt;/span>), &lt;span style="color:#b84">&amp;#34;ImGui + SFML = &amp;lt;3&amp;#34;&lt;/span>);
window.setFramerateLimit(&lt;span style="color:#099">60&lt;/span>);
ImGui&lt;span style="font-weight:bold">::&lt;/span>SFML&lt;span style="font-weight:bold">::&lt;/span>Init(window);
sf&lt;span style="font-weight:bold">::&lt;/span>CircleShape shape(&lt;span style="color:#099">100.f&lt;/span>);
shape.setFillColor(sf&lt;span style="font-weight:bold">::&lt;/span>Color&lt;span style="font-weight:bold">::&lt;/span>Green);
sf&lt;span style="font-weight:bold">::&lt;/span>Clock deltaClock;
&lt;span style="font-weight:bold">while&lt;/span> (window.isOpen()) {
sf&lt;span style="font-weight:bold">::&lt;/span>Event event;
&lt;span style="font-weight:bold">while&lt;/span> (window.pollEvent(event)) {
ImGui&lt;span style="font-weight:bold">::&lt;/span>SFML&lt;span style="font-weight:bold">::&lt;/span>ProcessEvent(window, event);
&lt;span style="font-weight:bold">if&lt;/span> (event.type &lt;span style="font-weight:bold">==&lt;/span> sf&lt;span style="font-weight:bold">::&lt;/span>Event&lt;span style="font-weight:bold">::&lt;/span>Closed) {
window.close();
}
}
ImGui&lt;span style="font-weight:bold">::&lt;/span>SFML&lt;span style="font-weight:bold">::&lt;/span>Update(window, deltaClock.restart());
ImGui&lt;span style="font-weight:bold">::&lt;/span>Begin(&lt;span style="color:#b84">&amp;#34;Hello, world!&amp;#34;&lt;/span>);
ImGui&lt;span style="font-weight:bold">::&lt;/span>Button(&lt;span style="color:#b84">&amp;#34;Look at this pretty button&amp;#34;&lt;/span>);
ImGui&lt;span style="font-weight:bold">::&lt;/span>End();
window.clear();
window.draw(shape);
ImGui&lt;span style="font-weight:bold">::&lt;/span>SFML&lt;span style="font-weight:bold">::&lt;/span>Render(window);
window.display();
}
ImGui&lt;span style="font-weight:bold">::&lt;/span>SFML&lt;span style="font-weight:bold">::&lt;/span>Shutdown();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You&amp;rsquo;ll see something like this:&lt;/p>
&lt;p>&lt;img src="rgb1.png" alt="First example">&lt;/p>
&lt;p>Try to change some stuff. Double click on r/g/b field to set values precisely, or just drag some widgets to change window&amp;rsquo;s background color. Press the button to change window title.
Here, it works!&lt;/p>
&lt;p>&lt;img src="rgb2.png" alt="First example">
Awesome! Now let&amp;rsquo;s see how it works.&lt;/p>
&lt;p>ImGui is initialized by calling &lt;code>ImGui::SFML::Init&lt;/code> function to which you pass your &lt;code>sf::RenderWindow&lt;/code>. This creates internal default font atlas. See how you can use other fonts in &lt;a href="https://github.com/eliasdaler/imgui-sfml#fonts-how-to">Fonts how-to section&lt;/a> of imgui-sfml&amp;rsquo;s README.&lt;/p>
&lt;p>Shutting down is done with &lt;code>ImGui::SFML::Shutdown&lt;/code> call which cleans some things up. (Deleting internal font atlas, if it&amp;rsquo;s used, for example).&lt;/p>
&lt;p>There are two phases of using ImGui in your game loop: &lt;strong>update&lt;/strong> and &lt;strong>render&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Updating&lt;/strong> consists of &lt;em>event processing&lt;/em>, &lt;em>state update&lt;/em> and &lt;em>widget update&lt;/em>. Event processing is done by calling &lt;code>ImGui::SFML::ProcessEvent&lt;/code> and it&amp;rsquo;s almost the same as processing SFML events. It&amp;rsquo;s used to process keyboard and mouse input and handle window resize and focus events. State update (which is being done by calling &lt;code>ImGui::SFML::Update&lt;/code>) updates delta time which ImGui uses internally, so you have to pass it using your delta time clock, as well as mouse coordinates (or your window relative to which mouse coordinates will be taken). &lt;code>ImGui::NewFrame&lt;/code> is also being called here and you can call ImGui widget creation functions after that. Calling stuff like &lt;code>ImGui::Button&lt;/code> or &lt;code>ImGui::Color3Edit&lt;/code> updates widgets and it also generates one draw list which is used for rendering later.&lt;/p>
&lt;p>&lt;strong>Drawing&lt;/strong> is done with &lt;code>ImGui::SFML::Render&lt;/code> call.&lt;/p>
&lt;blockquote class="hint-danger">
Don&amp;rsquo;t call &lt;code>ImGui::Render&lt;/code>, only call &lt;code>ImGui::SFML::Render&lt;/code>
&lt;/blockquote>
&lt;blockquote class="hint-info">
You must create all widgets between &lt;code>ImGui::SFML::Update()&lt;/code> and &lt;code>ImGui::Render()&lt;/code>.
&lt;/blockquote>
&lt;p>If you&amp;rsquo;re updating more than you draw, then you can either update ImGui once per frame or call &lt;code>ImGui::EndFrame&lt;/code> at the end of your update function.&lt;/p>
&lt;p>Widgets are easily created by calling corresponding functions (more about them in the next part). For example, you can call &lt;code>ImGui::InputInt&lt;/code> and pass a pointer to int there.When you change widget&amp;rsquo;s value, the integer is changed too.
Buttons work pretty easy too – they don&amp;rsquo;t need callbacks, you just wrap code which you want to call after the button is pressed in &lt;code>if(ImGui::Button(…)) { … }&lt;/code> and that&amp;rsquo;s all you have to do.&lt;/p>
&lt;p>Call &lt;code>ImGui::ShowTestWindow&lt;/code> somewhere when you create widgets and you&amp;rsquo;ll get a nice window with lots of examples of ImGui stuff. This is very useful as example of how to do stuff with ImGui. Just look for the thing you want to make in this test window and you&amp;rsquo;ll easily find how to do it in corresponding part of imgui_demo.cpp.&lt;/p>
&lt;h2 id="useful-overloads-for-sfml">Useful overloads for SFML&lt;/h2>
&lt;p>There are also some useful overloads implemented in SFML ImGui binding. For example, you can use &lt;code>ImGui::Image&lt;/code> and &lt;code>ImGui::ImageButton&lt;/code> with &lt;code>sf::Textures&lt;/code> and &lt;code>sf::Sprites&lt;/code>! I&amp;rsquo;ve also defined implicit conversions between &lt;code>ImVec2&lt;/code> and &lt;code>sf::Vector2f&lt;/code>, so you can pass &lt;code>sf::Vector2f&lt;/code> to ImGui&amp;rsquo;s functions without needing to cast explicitly. You can also draw lines and rects with &lt;code>DrawLine&lt;/code>, &lt;code>DrawRect&lt;/code>, &lt;code>DrawRectFilled&lt;/code>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>As you can see, using ImGui is easy and it&amp;rsquo;s easy to start doing really impressive and useful stuff with it right away. Thank you for reading this tutorial, I hope it was useful and that ImGui will help you make better tools and greater games as the result of having awesome tools.&lt;/p></description></item><item><title>CppCast</title><link>https://eliasdaler.github.io/hugo-test/posts/cppcast/</link><pubDate>Sat, 09 Jul 2016 01:05:00 +0300</pubDate><guid>https://eliasdaler.github.io/hugo-test/posts/cppcast/</guid><description>&lt;p>&lt;img src="cppcast.jpg" alt="Me on CppCast">&lt;/p>
&lt;p>I recently gave an interview on &lt;strong>CppCast&lt;/strong>!
Listen to it &lt;a href="http://cppcast.com/2016/07/elias-daler">here&lt;/a>.&lt;/p>
&lt;p>Here are my some thoughts about CppCast and the episode.&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h2 id="about-cppcast">About CppCast&lt;/h2>
&lt;p>If you&amp;rsquo;re never heard of &lt;strong>CppCast&lt;/strong> before - it&amp;rsquo;s one of the most amazing podcasts ever! The guests are always interesting and the discussions are very informative. The hosts know what to ask and what to talk about - they&amp;rsquo;re C++ developers themselves.
They also get awesome guests on the show. For example, there are episodes with people like &lt;a href="http://cppcast.com/2015/09/scott-meyers/">Scott Meyers&lt;/a>, &lt;a href="http://cppcast.com/2015/10/andrei-alexandrescu/">Andrei Alexandrescu&lt;/a> and &lt;a href="http://cppcast.com/2016/06/herb-sutter/">Herb Sutter&lt;/a>. These people are my heroes of programming, so it&amp;rsquo;s a big pleasure to be interviewed on the podcast of that caliber.&lt;/p>
&lt;h2 id="episode-with-me">Episode with me&lt;/h2>
&lt;p>I&amp;rsquo;ve never expected to be on the show so soon. I&amp;rsquo;ve joked about it: &amp;ldquo;Ah, I&amp;rsquo;ll be there in &lt;em>X&lt;/em> years when I get really successful&amp;rdquo;. It&amp;rsquo;s a big honor for me and I&amp;rsquo;m very thankful for Rob and Jason for making my dream of being on podcast come true.&lt;/p>
&lt;p>I&amp;rsquo;m sorry if I come of kinda derpy or awkward at times during the interview. First of all, I was pretty nervous and secondly, English is not my native language and I don&amp;rsquo;t speak in it in real life at all.
But still, I think I did pretty well and we discussed lots of neat stuff during the episode.&lt;/p>
&lt;h2 id="if-you-want-to-learn-about-luac-integration-andor-read-my-other-blog-posts">If you want to learn about Lua/C++ integration and/or read my other blog posts&lt;/h2>
&lt;p>This is my new blog, so check out my &lt;a href="https://eliasdaler.wordpress.com">old blog&lt;/a> for all the mentioned articles. If you want to start with Lua and C++, check out &lt;a href="https://eliasdaler.wordpress.com/2014/07/18/using-lua-with-cpp-luabridge/">LuaBridge tutorial&lt;/a> (though I recommend to use &lt;a href="https://github.com/ThePhD/sol2">sol2&lt;/a> as a binding library). If you want to see how you can use Lua in Practice, check out &lt;a href="https://eliasdaler.wordpress.com/2015/08/10/using-lua-and-cpp-in-practice/">Using Lua in practice&lt;/a> articles (there are five of them!). And check out &lt;a href="https://eliasdaler.wordpress.com/tag/dev-log/">Re:creation dev logs&lt;/a> for in-depth explanation of what I did about the game and how I make my game engine.&lt;/p>
&lt;p>The new articles are coming very soon, check out what I&amp;rsquo;m planning to write &lt;a href="https://eliasdaler.github.io/first-post">here&lt;/a> (I promised that there&amp;rsquo;ll be some when the podcast airs, but I didn&amp;rsquo;t think that episode will come out so soon, so sorry about that). I think these articles will be even better, there&amp;rsquo;s a lot of things I&amp;rsquo;ve learned during the last few years.&lt;/p>
&lt;p>Thanks for reading and listening. Please let me know what you thought of the episode in the comments!&lt;/p></description></item></channel></rss>